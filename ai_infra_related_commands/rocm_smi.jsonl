{"id":"unionid","kind":"union","language":"C++","prot":"public","compoundname":"id","title":"","briefdescription":"This union holds the value of an . The value may be a function name, or an ennumerated variant value of types such as , , etc.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga7021415ddf5e3e13a092bf3a88e68ff9","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t id::id","argsstring":null,"name":"id","briefdescription":"uint64_t representation of value","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaf4f5c5ec4274dd77200b227e8942c0f9","prot":"public","static":"no","mutable":"no","type":"const char *","definition":"const char* id::name","argsstring":null,"name":"name","briefdescription":"name string (applicable to functions only)","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga3969fcd7fc162cd06cf4309bf9788731","prot":"public","static":"no","mutable":"no","type":"rsmi_memory_type_t","definition":"rsmi_memory_type_t id::memory_type","argsstring":null,"name":"memory_type","briefdescription":"< Used for  variants","detaileddescription":"Used for variants","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga03cf949dae67d4719f7218d7c1826f22","prot":"public","static":"no","mutable":"no","type":"rsmi_temperature_metric_t","definition":"rsmi_temperature_metric_t id::temp_metric","argsstring":null,"name":"temp_metric","briefdescription":"Used for  variants.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaae5a6196d216bde7c2b1e54de07b6105","prot":"public","static":"no","mutable":"no","type":"rsmi_event_type_t","definition":"rsmi_event_type_t id::evnt_type","argsstring":null,"name":"evnt_type","briefdescription":"Used for  variants.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga6874560946cbbb15e8df3c77fa5a79b8","prot":"public","static":"no","mutable":"no","type":"rsmi_event_group_t","definition":"rsmi_event_group_t id::evnt_group","argsstring":null,"name":"evnt_group","briefdescription":"Used for  variants.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga687a7b397756879a62f168683bb81159","prot":"public","static":"no","mutable":"no","type":"rsmi_clk_type_t","definition":"rsmi_clk_type_t id::clk_type","argsstring":null,"name":"clk_type","briefdescription":"Used for  variants.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gad4ae2d23a844ad205772653cb8299293","prot":"public","static":"no","mutable":"no","type":"rsmi_fw_block_t","definition":"rsmi_fw_block_t id::fw_block","argsstring":null,"name":"fw_block","briefdescription":"Used for  variants.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaae8493f7ec4d2e6f0ef3509ec1c13917","prot":"public","static":"no","mutable":"no","type":"rsmi_gpu_block_t","definition":"rsmi_gpu_block_t id::gpu_block_type","argsstring":null,"name":"gpu_block_type","briefdescription":null,"detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga450f290df0d9fa917c5058b0c5f4c196","prot":"public","static":"no","mutable":"no","type":"union id::@0","definition":"union id::@0 id::@1","argsstring":null,"name":"@1","briefdescription":null,"detaileddescription":null,"inbodydescription":null}]}
{"id":"structmetrics__table__header__t","kind":"struct","language":"C++","prot":"public","compoundname":"metrics_table_header_t","title":"","briefdescription":"The following structures hold the gpu metrics values for a device.","detaileddescription":"Size and version information of metrics data","includes":["rocm_smi.h"],"memberdefs":[]}
{"id":"structrsmi__activity__metric__counter__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_activity_metric_counter_t","title":"","briefdescription":"This structure holds information about the possible activity averages. Specifically, the utilization counters.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga738104a3473356aaa729af9fd6bccdf0","prot":"public","static":"no","mutable":"no","type":"uint16_t","definition":"uint16_t rsmi_activity_metric_counter_t::average_gfx_activity","argsstring":null,"name":"average_gfx_activity","briefdescription":null,"detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gae26da41968ceb4817a32669cdba2a35a","prot":"public","static":"no","mutable":"no","type":"uint16_t","definition":"uint16_t rsmi_activity_metric_counter_t::average_umc_activity","argsstring":null,"name":"average_umc_activity","briefdescription":"memory controller","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga029f59656b95a3dafeaaa258b5d99039","prot":"public","static":"no","mutable":"no","type":"uint16_t","definition":"uint16_t rsmi_activity_metric_counter_t::average_mm_activity","argsstring":null,"name":"average_mm_activity","briefdescription":"UVD or VCN.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__counter__value__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_counter_value_t","title":"","briefdescription":"","detaileddescription":"Counter value","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga1b358c32983f6a0fa5b6dc568480b96d","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_counter_value_t::value","argsstring":null,"name":"value","briefdescription":"Counter value.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga28e4d796dc7bcefa526c02ac48f274bd","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_counter_value_t::time_enabled","argsstring":null,"name":"time_enabled","briefdescription":null,"detaileddescription":"Time that the counter was enabled (in nanoseconds)","inbodydescription":null},{"kind":"variable","id":"group__GPU_1gab8deb1a075ac7e64022b5509d08dd581","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_counter_value_t::time_running","argsstring":null,"name":"time_running","briefdescription":null,"detaileddescription":"Time that the counter was running (in nanoseconds)","inbodydescription":null}]}
{"id":"structrsmi__error__count__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_error_count_t","title":"","briefdescription":"This structure holds error counts.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga6ac4b7d9c5960b24eff09f7bb375fdf2","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_error_count_t::correctable_err","argsstring":null,"name":"correctable_err","briefdescription":"Accumulated correctable errors.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gab5b7a70f686a93e9ac2b04cc1f29e3a9","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_error_count_t::uncorrectable_err","argsstring":null,"name":"uncorrectable_err","briefdescription":"Accumulated uncorrectable errors.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__evt__notification__data__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_evt_notification_data_t","title":"","briefdescription":"","detaileddescription":"Event notification data returned from event notification API","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gab1a0b4da5ef2ad915780abc341881378","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_evt_notification_data_t::dv_ind","argsstring":null,"name":"dv_ind","briefdescription":"Index of device that corresponds to the event.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga7c5960c6fb38054411e6547dceb6c70c","prot":"public","static":"no","mutable":"no","type":"rsmi_evt_notification_type_t","definition":"rsmi_evt_notification_type_t rsmi_evt_notification_data_t::event","argsstring":null,"name":"event","briefdescription":"Event type.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga7acba651c83c3c538ba0daf35fcf9bdd","prot":"public","static":"no","mutable":"no","type":"char","definition":"char rsmi_evt_notification_data_t::message[MAX_EVENT_NOTIFICATION_MSG_SIZE]","argsstring":"[MAX_EVENT_NOTIFICATION_MSG_SIZE]","name":"message","briefdescription":"Event message.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__freq__volt__region__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_freq_volt_region_t","title":"","briefdescription":"This structure holds 2 's, one for frequency and one for voltage. These 2 ranges indicate the range of possible values for the corresponding .","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga271ad3419dc5c537e6002a47f67d74d8","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_freq_volt_region_t::freq_range","argsstring":null,"name":"freq_range","briefdescription":"The frequency range for this VDDC Curve point.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga155aef4d5afd6451307ae6297a4975d6","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_freq_volt_region_t::volt_range","argsstring":null,"name":"volt_range","briefdescription":"The voltage range for this VDDC Curve point.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__frequencies__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_frequencies_t","title":"","briefdescription":"This structure holds information about clock frequencies.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gadeb9b847d2c1c626c91ca58129c06c1e","prot":"public","static":"no","mutable":"no","type":"bool","definition":"bool rsmi_frequencies_t::has_deep_sleep","argsstring":null,"name":"has_deep_sleep","briefdescription":null,"detaileddescription":"Deep Sleep frequency is only supported by some GPUs","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga77dbb081a65c02c45578e1c984ad9e6d","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_frequencies_t::num_supported","argsstring":null,"name":"num_supported","briefdescription":null,"detaileddescription":"The number of supported frequencies","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga22a3f285cd0b18c621e4a23a0e9f3735","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_frequencies_t::current","argsstring":null,"name":"current","briefdescription":null,"detaileddescription":"The current frequency index","inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaaf24f211127e189b84aef40981365daf","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_frequencies_t::frequency[RSMI_MAX_NUM_FREQUENCIES]","argsstring":"[RSMI_MAX_NUM_FREQUENCIES]","name":"frequency","briefdescription":null,"detaileddescription":"List of frequencies. Only the first num_supported frequencies are valid.","inbodydescription":null}]}
{"id":"structrsmi__gpu__metrics__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_gpu_metrics_t","title":"","briefdescription":"","detaileddescription":"","includes":[],"memberdefs":[]}
{"id":"structrsmi__od__vddc__point__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_od_vddc_point_t","title":"","briefdescription":"This structure represents a point on the frequency-voltage plane.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga02d367800f06170c4d50b38b92b4ec93","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_od_vddc_point_t::frequency","argsstring":null,"name":"frequency","briefdescription":"Frequency coordinate (in Hz)","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaa56035842f75ecdf7cab268eb99a7914","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_od_vddc_point_t::voltage","argsstring":null,"name":"voltage","briefdescription":"Voltage coordinate (in mV)","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__od__volt__curve__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_od_volt_curve_t","title":"","briefdescription":"","detaileddescription":"number of 's","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga7310460b4175698906957bee5d7125d1","prot":"public","static":"no","mutable":"no","type":"rsmi_od_vddc_point_t","definition":"rsmi_od_vddc_point_t rsmi_od_volt_curve_t::vc_points[RSMI_NUM_VOLTAGE_CURVE_POINTS]","argsstring":"[RSMI_NUM_VOLTAGE_CURVE_POINTS]","name":"vc_points","briefdescription":null,"detaileddescription":"Array of 's that make up the voltage frequency curve points.","inbodydescription":null}]}
{"id":"structrsmi__od__volt__freq__data__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_od_volt_freq_data_t","title":"","briefdescription":"This structure holds the frequency-voltage values for a device.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga93ef0c02355341ace58cba421c16455a","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_od_volt_freq_data_t::curr_sclk_range","argsstring":null,"name":"curr_sclk_range","briefdescription":"The current SCLK frequency range.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga70a25c23cae0d17d0600efdedf61b0e9","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_od_volt_freq_data_t::curr_mclk_range","argsstring":null,"name":"curr_mclk_range","briefdescription":null,"detaileddescription":"The current MCLK frequency range; (upper bound only)","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga781bd05ba23d042df2d429b88e69c93d","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_od_volt_freq_data_t::sclk_freq_limits","argsstring":null,"name":"sclk_freq_limits","briefdescription":"The range possible of SCLK values.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga1419cb540a215467a781a2cb67b2a3fb","prot":"public","static":"no","mutable":"no","type":"rsmi_range_t","definition":"rsmi_range_t rsmi_od_volt_freq_data_t::mclk_freq_limits","argsstring":null,"name":"mclk_freq_limits","briefdescription":"The range possible of MCLK values.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gaf0c2c0fabc30a55eec07dc046b6a64c9","prot":"public","static":"no","mutable":"no","type":"rsmi_od_volt_curve_t","definition":"rsmi_od_volt_curve_t rsmi_od_volt_freq_data_t::curve","argsstring":null,"name":"curve","briefdescription":"The current voltage curve.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga17655208a2fd81e216d2041590ae2181","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_od_volt_freq_data_t::num_regions","argsstring":null,"name":"num_regions","briefdescription":"The number of voltage curve regions.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__pcie__bandwidth__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_pcie_bandwidth_t","title":"","briefdescription":"This structure holds information about the possible PCIe bandwidths. Specifically, the possible transfer rates and their associated numbers of lanes are stored here.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga560eeafdef9ae72d60a2cb1cb6d459bc","prot":"public","static":"no","mutable":"no","type":"rsmi_frequencies_t","definition":"rsmi_frequencies_t rsmi_pcie_bandwidth_t::transfer_rate","argsstring":null,"name":"transfer_rate","briefdescription":null,"detaileddescription":"Transfer rates (T\/s) that are possible","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga9f828751a73d42b3d8c443f033b62b6a","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_pcie_bandwidth_t::lanes[RSMI_MAX_NUM_FREQUENCIES]","argsstring":"[RSMI_MAX_NUM_FREQUENCIES]","name":"lanes","briefdescription":null,"detaileddescription":"List of lanes for corresponding transfer rate. Only the first num_supported bandwidths are valid.","inbodydescription":null}]}
{"id":"structrsmi__power__profile__status__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_power_profile_status_t","title":"","briefdescription":"This structure contains information about which power profiles are supported by the system for a given device, and which power profile is currently active.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga57045f93b1157bcabdc7f508ab193343","prot":"public","static":"no","mutable":"no","type":"rsmi_bit_field_t","definition":"rsmi_bit_field_t rsmi_power_profile_status_t::available_profiles","argsstring":null,"name":"available_profiles","briefdescription":null,"detaileddescription":"Which profiles are supported by this system","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga80353c0dc197edaff755d32e5e57b334","prot":"public","static":"no","mutable":"no","type":"rsmi_power_profile_preset_masks_t","definition":"rsmi_power_profile_preset_masks_t rsmi_power_profile_status_t::current","argsstring":null,"name":"current","briefdescription":null,"detaileddescription":"Which power profile is currently active","inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga4054bff029b2a87bd52ad5fbbaa83a3c","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_power_profile_status_t::num_profiles","argsstring":null,"name":"num_profiles","briefdescription":null,"detaileddescription":"How many power profiles are available","inbodydescription":null}]}
{"id":"structrsmi__process__info__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_process_info_t","title":"","briefdescription":"This structure contains information specific to a process.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1ga60da72e2184d806c863e7181ae401173","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_process_info_t::process_id","argsstring":null,"name":"process_id","briefdescription":"Process ID.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga5d2d3a1e08cd08d2c2ba3b49bcb1b7c1","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_process_info_t::pasid","argsstring":null,"name":"pasid","briefdescription":"PASID.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gadc43b49909f59b0982810fca8c967b5b","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_process_info_t::vram_usage","argsstring":null,"name":"vram_usage","briefdescription":"VRAM usage.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga72ad9ad700761c0e6c5e98895ed4d653","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_process_info_t::sdma_usage","argsstring":null,"name":"sdma_usage","briefdescription":"SDMA usage in microseconds.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga257dcee5554418365c273b8f8de2b5f5","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_process_info_t::cu_occupancy","argsstring":null,"name":"cu_occupancy","briefdescription":"Compute Unit usage in percent.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__range__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_range_t","title":"","briefdescription":"This structure represents a range (e.g., frequencies or voltages).","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gae1e079cc87fd387fe27f7be12164bb97","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_range_t::lower_bound","argsstring":null,"name":"lower_bound","briefdescription":"Lower bound of range.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gada0ce1c1759285dfa46cf5e0e61b0e19","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_range_t::upper_bound","argsstring":null,"name":"upper_bound","briefdescription":"Upper bound of range.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__retired__page__record__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_retired_page_record_t","title":"","briefdescription":"Reserved Memory Page Record.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gac917f101462599fa338d2305cd4dba17","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_retired_page_record_t::page_address","argsstring":null,"name":"page_address","briefdescription":"Start address of page.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga17154cc2dc7ea34dc05fc4f81a87c5f7","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_retired_page_record_t::page_size","argsstring":null,"name":"page_size","briefdescription":"Page size.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga67501de625d6dc642003640bce846877","prot":"public","static":"no","mutable":"no","type":"rsmi_memory_page_status_t","definition":"rsmi_memory_page_status_t rsmi_retired_page_record_t::status","argsstring":null,"name":"status","briefdescription":"Page \"reserved\" status.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__utilization__counter__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_utilization_counter_t","title":"","briefdescription":"The utilization counter data.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gab27506f9a9ca55fc31a488a06973250b","prot":"public","static":"no","mutable":"no","type":"RSMI_UTILIZATION_COUNTER_TYPE","definition":"RSMI_UTILIZATION_COUNTER_TYPE rsmi_utilization_counter_t::type","argsstring":null,"name":"type","briefdescription":"Utilization counter type.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gafd5ac01392c7a37cc465b3d8565aa056","prot":"public","static":"no","mutable":"no","type":"uint64_t","definition":"uint64_t rsmi_utilization_counter_t::value","argsstring":null,"name":"value","briefdescription":"Utilization counter value.","detaileddescription":null,"inbodydescription":null}]}
{"id":"structrsmi__version__t","kind":"struct","language":"C++","prot":"public","compoundname":"rsmi_version_t","title":"","briefdescription":"This structure holds version information.","detaileddescription":"","includes":["rocm_smi.h"],"memberdefs":[{"kind":"variable","id":"group__GPU_1gaf53c36e1f4c70432e481b23d6a4ab65c","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_version_t::major","argsstring":null,"name":"major","briefdescription":"Major version.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gad7f6d8d907d8d6dfb87c868cc2102e04","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_version_t::minor","argsstring":null,"name":"minor","briefdescription":"Minor version.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1ga4f2edab7f6f3bcb51757c715f2f95aec","prot":"public","static":"no","mutable":"no","type":"uint32_t","definition":"uint32_t rsmi_version_t::patch","argsstring":null,"name":"patch","briefdescription":"Patch, build or stepping version.","detaileddescription":null,"inbodydescription":null},{"kind":"variable","id":"group__GPU_1gac2bfb7e3d48f756e13acf0c070bc684a","prot":"public","static":"no","mutable":"no","type":"const char *","definition":"const char* rsmi_version_t::build","argsstring":null,"name":"build","briefdescription":"Build string.","detaileddescription":null,"inbodydescription":null}]}
{"id":"README_8md","kind":"file","language":"Markdown","prot":null,"compoundname":"README.md","title":"","briefdescription":"","detaileddescription":"","includes":[],"memberdefs":[]}
{"id":"rocm__smi_8h","kind":"file","language":"C++","prot":null,"compoundname":"rocm_smi.h","title":"","briefdescription":"The rocm_smi library api is new, and therefore subject to change either at the ABI or API level. Instead of marking every function prototype as \"unstable\", we are instead saying the API is unstable (i.e., changes are possible) while the major version remains 0. This means that if the API\/ABI changes, we will not increment the major version to 1. Once the ABI stabilizes, we will increment the major version to 1, and thereafter increment it on all ABI breaks.","detaileddescription":"Main header file for the ROCm SMI library. All required function, structure, enum, etc. definitions should be defined in this file.","includes":["stdint.h","stddef.h","stdbool.h","rocm_smi\/kfd_ioctl.h"],"memberdefs":[{"kind":"define","id":"rocm__smi_8h_1acce24b171e710e00f55f52f93f716374","prot":"public","static":"no","name":"RSMI_MAX_NUM_FREQUENCIES","briefdescription":null,"detaileddescription":"Guaranteed maximum possible number of supported frequencies (32 normal + 1 sleep frequency)","inbodydescription":null,"initializer":"33"},{"kind":"define","id":"rocm__smi_8h_1ae902d9be2cd4227bb688334f9d98135b","prot":"public","static":"no","name":"RSMI_MAX_FAN_SPEED","briefdescription":null,"detaileddescription":"Maximum possible value for fan speed. Should be used as the denominator when determining fan speed percentage.","inbodydescription":null,"initializer":"255"},{"kind":"define","id":"rocm__smi_8h_1a5b444073282d9226e7f7cbb9e866e91b","prot":"public","static":"no","name":"RSMI_NUM_VOLTAGE_CURVE_POINTS","briefdescription":"The number of points that make up a voltage-frequency curve definition.","detaileddescription":null,"inbodydescription":null,"initializer":"3"},{"kind":"define","id":"rocm__smi_8h_1a31154bb6aa0f7e6715ddc0050217d9a4","prot":"public","static":"no","name":"RSMI_EVENT_MASK_FROM_INDEX","briefdescription":null,"detaileddescription":"Macro to generate event bitmask from event id","inbodydescription":null,"initializer":"(1ULL << ((i) - 1))"},{"kind":"define","id":"rocm__smi_8h_1a35c6abcd4877b903de5a42aff6239b53","prot":"public","static":"no","name":"MAX_EVENT_NOTIFICATION_MSG_SIZE","briefdescription":"Maximum number of characters an event notification message will be.","detaileddescription":null,"inbodydescription":null,"initializer":"64"},{"kind":"define","id":"rocm__smi_8h_1ace335fd31bc62417f98f2a8e7f58c254","prot":"public","static":"no","name":"CPU_NODE_INDEX","briefdescription":null,"detaileddescription":"The CPU node index which will be used in rsmi_topo_get_link_type to query the link type between GPU and CPU","inbodydescription":null,"initializer":"0xFFFFFFFF"},{"kind":"define","id":"rocm__smi_8h_1a4c17a54b0da524d6639f75875b7a7be9","prot":"public","static":"no","name":"RSMI_MAX_NUM_POWER_PROFILES","briefdescription":"Number of possible power profiles that a system could support.","detaileddescription":null,"inbodydescription":null,"initializer":"(sizeof(rsmi_bit_field_t) * 8)"},{"kind":"define","id":"rocm__smi_8h_1abe25902a680784076246feaf0cee62a4","prot":"public","static":"no","name":"CENTRIGRADE_TO_MILLI_CENTIGRADE","briefdescription":"The following structure holds the gpu metrics values for a device.","detaileddescription":"Unit conversion factor for HBM temperatures","inbodydescription":null,"initializer":"1000"},{"kind":"define","id":"rocm__smi_8h_1a979bc49694c92278498ded7df98b6122","prot":"public","static":"no","name":"RSMI_NUM_HBM_INSTANCES","briefdescription":"This should match kRSMI_MAX_NUM_HBM_INSTANCES.","detaileddescription":null,"inbodydescription":null,"initializer":"4"},{"kind":"define","id":"rocm__smi_8h_1aad6fab3801a43f20ca29c2341a42209d","prot":"public","static":"no","name":"RSMI_MAX_NUM_VCNS","briefdescription":"This should match kRSMI_MAX_NUM_VCNS.","detaileddescription":null,"inbodydescription":null,"initializer":"4"},{"kind":"define","id":"rocm__smi_8h_1a3d3a537e8aade96b851e094f1d1d60f5","prot":"public","static":"no","name":"RSMI_MAX_NUM_JPEG_ENGS","briefdescription":"This should match kRSMI_MAX_JPEG_ENGINES.","detaileddescription":null,"inbodydescription":null,"initializer":"32"},{"kind":"define","id":"rocm__smi_8h_1a39ab3a9603471852f5b6057bab018e8f","prot":"public","static":"no","name":"RSMI_MAX_NUM_CLKS","briefdescription":"This should match kRSMI_MAX_NUM_CLKS.","detaileddescription":null,"inbodydescription":null,"initializer":"4"},{"kind":"define","id":"rocm__smi_8h_1ad3a34512c2e93b66d8be00bec851ea45","prot":"public","static":"no","name":"RSMI_MAX_NUM_XGMI_LINKS","briefdescription":"This should match kRSMI_MAX_NUM_XGMI_LINKS.","detaileddescription":null,"inbodydescription":null,"initializer":"8"},{"kind":"define","id":"rocm__smi_8h_1a5dc15c8206b57b85a0804d6a49cc0933","prot":"public","static":"no","name":"RSMI_MAX_NUM_GFX_CLKS","briefdescription":"This should match kRSMI_MAX_NUM_GFX_CLKS.","detaileddescription":null,"inbodydescription":null,"initializer":"8"},{"kind":"define","id":"rocm__smi_8h_1ae8f8dcc773f106f7de1c27a48e37d023","prot":"public","static":"no","name":"RSMI_DEFAULT_VARIANT","briefdescription":null,"detaileddescription":"Place-holder \"variant\" for functions that have don't have any variants, but do have monitors or sensors.","inbodydescription":null,"initializer":"0xFFFFFFFFFFFFFFFF"},{"kind":"enum","id":"rocm__smi_8h_1a195e7f838b52e457e2f1ec34719720a5","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_status_t","briefdescription":"Error codes retured by rocm_smi_lib functions.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5aeb785af1b078a9a5cf96c2c84a4663a1","prot":"public","name":"RSMI_STATUS_SUCCESS","initializer":"= 0x0","briefdescription":"Operation was successful.","detaileddescription":""},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a6bbfccb11a8a7decd8b82ff87e746cff","prot":"public","name":"RSMI_STATUS_INVALID_ARGS","initializer":null,"briefdescription":"Passed in arguments are not valid.","detaileddescription":""},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a73a37177af2da12670fba25c1bb2745c","prot":"public","name":"RSMI_STATUS_NOT_SUPPORTED","initializer":null,"briefdescription":"","detaileddescription":"The requested information or action is not available for the given input, on the given system"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5aabdeccee6a17f9f67d21f66bf773a381","prot":"public","name":"RSMI_STATUS_FILE_ERROR","initializer":null,"briefdescription":"","detaileddescription":"Problem accessing a file. This may because the operation is not supported by the Linux kernel version running on the executing machine"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5af97797f147724fb550f4c73a85838ede","prot":"public","name":"RSMI_STATUS_PERMISSION","initializer":null,"briefdescription":"","detaileddescription":"Permission denied\/EACCESS file error. Many functions require root access to run."},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5ad7b08a89e58b56d688b8556343bb5230","prot":"public","name":"RSMI_STATUS_OUT_OF_RESOURCES","initializer":null,"briefdescription":"","detaileddescription":"Unable to acquire memory or other resource"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5adbb6efa9e9001f985f99a8a4326ca78c","prot":"public","name":"RSMI_STATUS_INTERNAL_EXCEPTION","initializer":null,"briefdescription":"An internal exception was caught.","detaileddescription":""},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5af4075c88c7d352e457c3d5529bd9817b","prot":"public","name":"RSMI_STATUS_INPUT_OUT_OF_BOUNDS","initializer":null,"briefdescription":"","detaileddescription":"The provided input is out of allowable or safe range"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a3535672198b2045e18115b025321e728","prot":"public","name":"RSMI_STATUS_INIT_ERROR","initializer":null,"briefdescription":"","detaileddescription":"An error occurred when rsmi initializing internal data structures"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a675bc1ccf7b5ca2045b38f36c8699651","prot":"public","name":"RSMI_INITIALIZATION_ERROR","initializer":"= RSMI_STATUS_INIT_ERROR","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5ad3c5f63228c24a8cf21de5ad634b3afe","prot":"public","name":"RSMI_STATUS_NOT_YET_IMPLEMENTED","initializer":null,"briefdescription":"","detaileddescription":"The requested function has not yet been implemented in the current system for the current devices"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a30ed5ed0375966a8fb0650539a469ef2","prot":"public","name":"RSMI_STATUS_NOT_FOUND","initializer":null,"briefdescription":"","detaileddescription":"An item was searched for but not found"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a658c7b78f80442ee90af983f082587dc","prot":"public","name":"RSMI_STATUS_INSUFFICIENT_SIZE","initializer":null,"briefdescription":"","detaileddescription":"Not enough resources were available for the operation"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5adae7fe627dbd3e3a947545fe8b599df3","prot":"public","name":"RSMI_STATUS_INTERRUPT","initializer":null,"briefdescription":"","detaileddescription":"An interrupt occurred during execution of function"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a8979539070027fa16b048951047ebefb","prot":"public","name":"RSMI_STATUS_UNEXPECTED_SIZE","initializer":null,"briefdescription":"","detaileddescription":"An unexpected amount of data was read"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a8472465c902f4b53dbb6e40d13b2537e","prot":"public","name":"RSMI_STATUS_NO_DATA","initializer":null,"briefdescription":"","detaileddescription":"No data was found for a given input"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a07d4ff0831eb4fffc1302ac9fd8b2d74","prot":"public","name":"RSMI_STATUS_UNEXPECTED_DATA","initializer":null,"briefdescription":"","detaileddescription":"The data read or provided to function is not what was expected"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5ab319f1907062c117aff4d8a93edf93fb","prot":"public","name":"RSMI_STATUS_BUSY","initializer":null,"briefdescription":"","detaileddescription":"A resource or mutex could not be acquired because it is already being used"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a15dc7b343267551b08ab10b177bb86e1","prot":"public","name":"RSMI_STATUS_REFCOUNT_OVERFLOW","initializer":null,"briefdescription":"","detaileddescription":"An internal reference counter exceeded INT32_MAX"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a5abdbe3d1f125536f92c003994159429","prot":"public","name":"RSMI_STATUS_SETTING_UNAVAILABLE","initializer":null,"briefdescription":"","detaileddescription":"Requested setting is unavailable for the current device"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a8dae6ec84c1a56c78e477bb2483a3e34","prot":"public","name":"RSMI_STATUS_AMDGPU_RESTART_ERR","initializer":null,"briefdescription":"","detaileddescription":"Could not successfully restart the amdgpu driver"},{"id":"rocm__smi_8h_1ga195e7f838b52e457e2f1ec34719720a5a311fbabc0ef81d3d74d433fb956cc69e","prot":"public","name":"RSMI_STATUS_UNKNOWN_ERROR","initializer":"= 0xFFFFFFFF","briefdescription":"An unknown error occurred.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1ac07a144c0269b9921f773da01e4778e3","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_init_flags_t","briefdescription":"Initialization flags.","detaileddescription":"Initialization flags may be OR'd together and passed to .","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gac07a144c0269b9921f773da01e4778e3ac1c7f87c5186be0f0bc2898ea405bf97","prot":"public","name":"RSMI_INIT_FLAG_ALL_GPUS","initializer":"= 0x1","briefdescription":"","detaileddescription":"Attempt to add all GPUs found (including non-AMD) to the list of devices from which SMI information can be retrieved. By default, only AMD devices are enumerated by RSMI."},{"id":"rocm__smi_8h_1gac07a144c0269b9921f773da01e4778e3a7844f513825d31fa172db8567dc153b7","prot":"public","name":"RSMI_INIT_FLAG_RESRV_TEST1","initializer":"= 0x800000000000000","briefdescription":"Reserved for test.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a3ee1ac8945bd94840d7412e9ef63cdd5","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_dev_perf_level_t","briefdescription":"PowerPlay performance levels.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5afc89504f9b24e255d87681cb162a73bf","prot":"public","name":"RSMI_DEV_PERF_LEVEL_AUTO","initializer":"= 0","briefdescription":"Performance level is \"auto\".","detaileddescription":""},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5adcc91a356961392afe320e0e9ed2e5b1","prot":"public","name":"RSMI_DEV_PERF_LEVEL_FIRST","initializer":"= RSMI_DEV_PERF_LEVEL_AUTO","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a1c20aa10a19446330b3da039b337012f","prot":"public","name":"RSMI_DEV_PERF_LEVEL_LOW","initializer":null,"briefdescription":"","detaileddescription":"Keep PowerPlay levels \"low\", regardless of workload"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a6e1e8286ca54c510f517d19f0577e22f","prot":"public","name":"RSMI_DEV_PERF_LEVEL_HIGH","initializer":null,"briefdescription":"","detaileddescription":"Keep PowerPlay levels \"high\", regardless of workload"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a21bdfb5d03fa8beed7c21d5dd1d55588","prot":"public","name":"RSMI_DEV_PERF_LEVEL_MANUAL","initializer":null,"briefdescription":"","detaileddescription":"Only use values defined by manually setting the RSMI_CLK_TYPE_SYS speed"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a875074abd576ba5e36f4f7da5b0cdcee","prot":"public","name":"RSMI_DEV_PERF_LEVEL_STABLE_STD","initializer":null,"briefdescription":"","detaileddescription":"Stable power state with profiling clocks"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5ac833cb0e7014165438b4356685ee0593","prot":"public","name":"RSMI_DEV_PERF_LEVEL_STABLE_PEAK","initializer":null,"briefdescription":"Stable power state with peak clocks.","detaileddescription":""},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a2bc49234c0c6735e006f602e85a32def","prot":"public","name":"RSMI_DEV_PERF_LEVEL_STABLE_MIN_MCLK","initializer":null,"briefdescription":"","detaileddescription":"Stable power state with minimum memory clock"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5ad0cb9645d34ae26cbcf3e3ff64ca440d","prot":"public","name":"RSMI_DEV_PERF_LEVEL_STABLE_MIN_SCLK","initializer":null,"briefdescription":"","detaileddescription":"Stable power state with minimum system clock"},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a53dc00cf744dbf8bf5807941b76a6af1","prot":"public","name":"RSMI_DEV_PERF_LEVEL_DETERMINISM","initializer":null,"briefdescription":"Performance determinism state.","detaileddescription":""},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5ad59687a1ff3fb50b6f1697b343d8841a","prot":"public","name":"RSMI_DEV_PERF_LEVEL_LAST","initializer":"= RSMI_DEV_PERF_LEVEL_DETERMINISM","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga3ee1ac8945bd94840d7412e9ef63cdd5a44eb855d669f7cd1afe2c5104ea2ab69","prot":"public","name":"RSMI_DEV_PERF_LEVEL_UNKNOWN","initializer":"= 0x100","briefdescription":"Unknown performance level.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a246df50ff75c391066b1ddfab16a90a8","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_sw_component_t","briefdescription":"Available clock types.","detaileddescription":"Software components","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga246df50ff75c391066b1ddfab16a90a8a94cc3285e41b54f011ab32d7e56c095a","prot":"public","name":"RSMI_SW_COMP_FIRST","initializer":"= 0x0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga246df50ff75c391066b1ddfab16a90a8a31ef7792bb9c12e2cc39d5e4a268afc3","prot":"public","name":"RSMI_SW_COMP_DRIVER","initializer":"= RSMI_SW_COMP_FIRST","briefdescription":"Driver.","detaileddescription":""},{"id":"rocm__smi_8h_1ga246df50ff75c391066b1ddfab16a90a8a37fdb7aca6fb66313362605412b67cb5","prot":"public","name":"RSMI_SW_COMP_LAST","initializer":"= RSMI_SW_COMP_DRIVER","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a283162f5834170d5f1840eac79097584","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_event_group_t","briefdescription":"Enum denoting an event group. The value of the enum is the base value for all the event enums in the group.","detaileddescription":"Event Groups","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga283162f5834170d5f1840eac79097584a5b1c81acbb243122655de56b6baa486b","prot":"public","name":"RSMI_EVNT_GRP_XGMI","initializer":"= 0","briefdescription":"Data Fabric (XGMI) related events.","detaileddescription":""},{"id":"rocm__smi_8h_1ga283162f5834170d5f1840eac79097584a5f8a19a9ec89ccb1be2f39e09a797eff","prot":"public","name":"RSMI_EVNT_GRP_XGMI_DATA_OUT","initializer":"= 10","briefdescription":"XGMI Outbound data.","detaileddescription":""},{"id":"rocm__smi_8h_1ga283162f5834170d5f1840eac79097584a633f1e749bb3f50a0f6dee145593aee0","prot":"public","name":"RSMI_EVNT_GRP_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1aa13b1ffc4975255778a252520710240a","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_event_type_t","briefdescription":"Event type enum. Events belonging to a particular event group  should begin enumerating at the  value for that group.","detaileddescription":"Event types","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa9d8b4014bd4f21dd446b5067b6a205ae","prot":"public","name":"RSMI_EVNT_FIRST","initializer":"= RSMI_EVNT_GRP_XGMI","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aac7ec222980b7840bbb2beac840146e5b","prot":"public","name":"RSMI_EVNT_XGMI_FIRST","initializer":"= RSMI_EVNT_GRP_XGMI","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa41db09339fc042a856d256a181068cdc","prot":"public","name":"RSMI_EVNT_XGMI_0_NOP_TX","initializer":"= RSMI_EVNT_XGMI_FIRST","briefdescription":"NOPs sent to neighbor 0.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aaf6952f14f8d95a8d0e7cafa62a4b0e4d","prot":"public","name":"RSMI_EVNT_XGMI_0_REQUEST_TX","initializer":null,"briefdescription":"","detaileddescription":"Outgoing requests to neighbor 0"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aacd4b4740070ba8c1362c351e6b447db6","prot":"public","name":"RSMI_EVNT_XGMI_0_RESPONSE_TX","initializer":null,"briefdescription":"","detaileddescription":"Outgoing responses to neighbor 0"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aae8ea17ae4e04c8e1ea0b54075372c60a","prot":"public","name":"RSMI_EVNT_XGMI_0_BEATS_TX","initializer":null,"briefdescription":"Data beats sent to neighbor 0; Each beat represents 32 bytes.","detaileddescription":"XGMI throughput can be calculated by multiplying a BEATs event such as RSMI_EVNT_XGMI_0_BEATS_TX by 32 and dividing by the time for which event collection occurred, rsmi_counter_value_t.time_running (which is in nanoseconds). To get bytes per second, multiply this value by 109. Throughput = BEATS\/time_running * 109 (bytes\/second)"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa27b883406e39afa54f23bb07c03f9973","prot":"public","name":"RSMI_EVNT_XGMI_1_NOP_TX","initializer":null,"briefdescription":"NOPs sent to neighbor 1.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa5b0653ed03fc6ee3ebf728aeeacce845","prot":"public","name":"RSMI_EVNT_XGMI_1_REQUEST_TX","initializer":null,"briefdescription":"neighbor 1","detaileddescription":"Outgoing requests to"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa04a9de89809c8ec66c0fc29b7a5f5881","prot":"public","name":"RSMI_EVNT_XGMI_1_RESPONSE_TX","initializer":null,"briefdescription":"","detaileddescription":"Outgoing responses to neighbor 1"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa21cdd98f53a6c185d26abe4e1c7d73d1","prot":"public","name":"RSMI_EVNT_XGMI_1_BEATS_TX","initializer":null,"briefdescription":"","detaileddescription":"Data beats sent to neighbor 1; Each beat represents 32 bytes"},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aafdb318048051d0f70e0ae1b5908b9169","prot":"public","name":"RSMI_EVNT_XGMI_LAST","initializer":"= RSMI_EVNT_XGMI_1_BEATS_TX","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa258fc41311391d5f657b8134a01dfae2","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_FIRST","initializer":"= RSMI_EVNT_GRP_XGMI_DATA_OUT","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aaf0de38322f5121a7c979a957669befae","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_0","initializer":"= RSMI_EVNT_XGMI_DATA_OUT_FIRST","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aaceae1f00029b97d3d625eba4351f9d45","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_1","initializer":null,"briefdescription":"Outbound beats to neighbor 1.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aaa8a818e8a485c1a8ff99870042ba85e9","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_2","initializer":null,"briefdescription":"Outbound beats to neighbor 2.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa721883ee462c12ee475d72e1ece22c6b","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_3","initializer":null,"briefdescription":"Outbound beats to neighbor 3.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa8c32fa5b82944863977d7349ef2484d3","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_4","initializer":null,"briefdescription":"Outbound beats to neighbor 4.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aa0f0c33bf20bc5f8f88450c6114165b5f","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_5","initializer":null,"briefdescription":"Outbound beats to neighbor 5.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aadd57b386cd8b92879f8a79b2fab21aa6","prot":"public","name":"RSMI_EVNT_XGMI_DATA_OUT_LAST","initializer":"= RSMI_EVNT_XGMI_DATA_OUT_5","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa13b1ffc4975255778a252520710240aab5929b3a6f7499ae612bc71a6e685bb2","prot":"public","name":"RSMI_EVNT_LAST","initializer":"= RSMI_EVNT_XGMI_DATA_OUT_LAST","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1adb72f478d8bd440e0ace8712e633da23","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_counter_command_t","briefdescription":null,"detaileddescription":"Event counter commands","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gadb72f478d8bd440e0ace8712e633da23a3c2eacb5e565df2980c142ab8a6d6284","prot":"public","name":"RSMI_CNTR_CMD_START","initializer":"= 0","briefdescription":"Start the counter.","detaileddescription":""},{"id":"rocm__smi_8h_1gadb72f478d8bd440e0ace8712e633da23a5217f4c6431ea5f98a1894cf90206dba","prot":"public","name":"RSMI_CNTR_CMD_STOP","initializer":null,"briefdescription":"","detaileddescription":"Stop the counter; note that this should not be used before reading."}]},{"kind":"enum","id":"rocm__smi_8h_1a51a29e42a7b07b2d1b93b54b310ad7e9","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_evt_notification_type_t","briefdescription":null,"detaileddescription":"Event notification event types","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9a66bee18a8fb53483b9af0baa009a100c","prot":"public","name":"RSMI_EVT_NOTIF_VMFAULT","initializer":"= KFD_SMI_EVENT_VMFAULT","briefdescription":"VM page fault.","detaileddescription":""},{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9a20d8a9d24dfa7fdff32b1bc774219ad6","prot":"public","name":"RSMI_EVT_NOTIF_FIRST","initializer":"= RSMI_EVT_NOTIF_VMFAULT","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9a252f5309aadc0976c88ffc82190dc340","prot":"public","name":"RSMI_EVT_NOTIF_THERMAL_THROTTLE","initializer":"= KFD_SMI_EVENT_THERMAL_THROTTLE","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9a451de40f9d02069e1b7fe117c200d7aa","prot":"public","name":"RSMI_EVT_NOTIF_GPU_PRE_RESET","initializer":"= KFD_SMI_EVENT_GPU_PRE_RESET","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9a01d18813e1490d0fe293725d2ec17857","prot":"public","name":"RSMI_EVT_NOTIF_GPU_POST_RESET","initializer":"= KFD_SMI_EVENT_GPU_POST_RESET","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga51a29e42a7b07b2d1b93b54b310ad7e9ae342bca25167852fdec2601de34e903e","prot":"public","name":"RSMI_EVT_NOTIF_LAST","initializer":"= RSMI_EVT_NOTIF_GPU_POST_RESET","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1adff8e3e0b004b35d90348455f807f856","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_clk_type_t","briefdescription":null,"detaileddescription":"Clock types","inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856ad3bf5182ba2f8475b75f8689570e6995","prot":"public","name":"RSMI_CLK_TYPE_SYS","initializer":"= 0x0","briefdescription":"System clock.","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a5ced3acc0428f4229fcb6cbdb891397c","prot":"public","name":"RSMI_CLK_TYPE_FIRST","initializer":"= RSMI_CLK_TYPE_SYS","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856ab89d5ac1638ba46a0aedd70d46dfa161","prot":"public","name":"RSMI_CLK_TYPE_DF","initializer":null,"briefdescription":"","detaileddescription":"Data Fabric clock (for ASICs running on a separate clock)"},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a16a834aa7a4a5ede51e465af95dad3af","prot":"public","name":"RSMI_CLK_TYPE_DCEF","initializer":null,"briefdescription":"Display Controller Engine clock.","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856ab0ffd1bbce398e60380ca2d2db6febc0","prot":"public","name":"RSMI_CLK_TYPE_SOC","initializer":null,"briefdescription":"SOC clock.","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a05648c7f74d2d38f8177c9eca9d21615","prot":"public","name":"RSMI_CLK_TYPE_MEM","initializer":null,"briefdescription":"Memory clock.","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a269e3b510a54807b1650d3bcabc924ee","prot":"public","name":"RSMI_CLK_TYPE_PCIE","initializer":null,"briefdescription":"PCIE clock.","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a40163bbf3f940012b4f5f94a1b618aea","prot":"public","name":"RSMI_CLK_TYPE_LAST","initializer":"= RSMI_CLK_TYPE_MEM","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gadff8e3e0b004b35d90348455f807f856a47cfe3a72ba743469ccdbe1be838339e","prot":"public","name":"RSMI_CLK_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a67a0fa33c23aa149b6e1f1f353a22856","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_compute_partition_type_t","briefdescription":"Compute Partition. This enum is used to identify various compute partitioning settings.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856a1767c7f3ceb68c25a20fbdca1bed7d50","prot":"public","name":"RSMI_COMPUTE_PARTITION_INVALID","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856ae3d580bed45f3e339627e7c3026c042d","prot":"public","name":"RSMI_COMPUTE_PARTITION_CPX","initializer":null,"briefdescription":"","detaileddescription":"Core mode (CPX)- Per-chip XCC with shared memory"},{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856a0c4bd9f712d698bf1e995b876b7bc67d","prot":"public","name":"RSMI_COMPUTE_PARTITION_SPX","initializer":null,"briefdescription":"","detaileddescription":"Single GPU mode (SPX)- All XCCs work together with shared memory"},{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856a2c1d593b0cf83d9cf41a2dfcdb1c7484","prot":"public","name":"RSMI_COMPUTE_PARTITION_DPX","initializer":null,"briefdescription":"","detaileddescription":"Dual GPU mode (DPX)- Half XCCs work together with shared memory"},{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856aaa00aba25b5cc562fb6a39c46a6172c0","prot":"public","name":"RSMI_COMPUTE_PARTITION_TPX","initializer":null,"briefdescription":"","detaileddescription":"Triple GPU mode (TPX)- One-third XCCs work together with shared memory"},{"id":"rocm__smi_8h_1ga67a0fa33c23aa149b6e1f1f353a22856a8e3dfa94dd79ad7bad8488ce6315b5ac","prot":"public","name":"RSMI_COMPUTE_PARTITION_QPX","initializer":null,"briefdescription":"","detaileddescription":"Quad GPU mode (QPX)- Quarter XCCs work together with shared memory"}]},{"kind":"enum","id":"rocm__smi_8h_1ae5af62ab63dd972b3918db0f97d0f48a","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_memory_partition_type_t","briefdescription":"Memory Partitions. This enum is used to identify various memory partition types.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gae5af62ab63dd972b3918db0f97d0f48aaf42ef07efecfb73e3f2e9961726e4c84","prot":"public","name":"RSMI_MEMORY_PARTITION_UNKNOWN","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gae5af62ab63dd972b3918db0f97d0f48aadbb96c4a57171a44374526c05017a5a0","prot":"public","name":"RSMI_MEMORY_PARTITION_NPS1","initializer":null,"briefdescription":"","detaileddescription":"NPS1 - All CCD & XCD data is interleaved accross all 8 HBM stacks (all stacks\/1)."},{"id":"rocm__smi_8h_1gae5af62ab63dd972b3918db0f97d0f48aabf8c1b7124d8c9e8bb9908e7fa4866b4","prot":"public","name":"RSMI_MEMORY_PARTITION_NPS2","initializer":null,"briefdescription":"","detaileddescription":"NPS2 - 2 sets of CCDs or 4 XCD interleaved accross the 4 HBM stacks per AID pair (8 stacks\/2)."},{"id":"rocm__smi_8h_1gae5af62ab63dd972b3918db0f97d0f48aaa6e487bd483c2e24bcb2ad0746d3ad81","prot":"public","name":"RSMI_MEMORY_PARTITION_NPS4","initializer":null,"briefdescription":"","detaileddescription":"NPS4 - Each XCD data is interleaved accross accross 2 (or single) HBM stacks (8 stacks\/8 or 8 stacks\/4)."},{"id":"rocm__smi_8h_1gae5af62ab63dd972b3918db0f97d0f48aa6d22246389b2744d5cc150eade42c41d","prot":"public","name":"RSMI_MEMORY_PARTITION_NPS8","initializer":null,"briefdescription":"","detaileddescription":"NPS8 - Each XCD uses a single HBM stack (8 stacks\/8). Or each XCD uses a single HBM stack & CCDs share 2 non-interleaved HBM stacks on its AID (AID[1,2,3] = 6 stacks\/6)."}]},{"kind":"enum","id":"rocm__smi_8h_1a90d27331dd58d5552cd08c5a37bbece2","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_temperature_metric_t","briefdescription":"Temperature Metrics. This enum is used to identify various temperature metrics. Corresponding values will be in millidegress Celcius.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a04e4bcdbf4d22f65ebbf10aecc21b2bb","prot":"public","name":"RSMI_TEMP_CURRENT","initializer":"= 0x0","briefdescription":"Temperature current value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2adbae71a24e4f508fa99777cf554dafa4","prot":"public","name":"RSMI_TEMP_FIRST","initializer":"= RSMI_TEMP_CURRENT","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a4ceaf10483f5f682e6993983c8107ad1","prot":"public","name":"RSMI_TEMP_MAX","initializer":null,"briefdescription":"Temperature max value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a4cc6104c4214723ef2e34c4a9f65a4f6","prot":"public","name":"RSMI_TEMP_MIN","initializer":null,"briefdescription":"Temperature min value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a98ed9c0077f8bce3caa4cd00a131fe02","prot":"public","name":"RSMI_TEMP_MAX_HYST","initializer":null,"briefdescription":"","detaileddescription":"Temperature hysteresis value for max limit. (This is an absolute temperature, not a delta)."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2ab24a2ef2755d1f1050446f87e4de2eb0","prot":"public","name":"RSMI_TEMP_MIN_HYST","initializer":null,"briefdescription":"","detaileddescription":"Temperature hysteresis value for min limit. (This is an absolute temperature, not a delta)."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2ad3e445dd71e35cb4b9205c54adf37807","prot":"public","name":"RSMI_TEMP_CRITICAL","initializer":null,"briefdescription":"","detaileddescription":"Temperature critical max value, typically greater than corresponding temp_max values."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2ac160c3f3ad53092cdbcc0c9277fd85d7","prot":"public","name":"RSMI_TEMP_CRITICAL_HYST","initializer":null,"briefdescription":"","detaileddescription":"Temperature hysteresis value for critical limit. (This is an absolute temperature, not a delta)."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a68863ff3450c017d2809be14d873a0e8","prot":"public","name":"RSMI_TEMP_EMERGENCY","initializer":null,"briefdescription":"","detaileddescription":"Temperature emergency max value, for chips supporting more than two upper temperature limits. Must be equal or greater than corresponding temp_crit values."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2ac66b25e430c1a71bcee578d00818580a","prot":"public","name":"RSMI_TEMP_EMERGENCY_HYST","initializer":null,"briefdescription":"","detaileddescription":"Temperature hysteresis value for emergency limit. (This is an absolute temperature, not a delta)."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a247ce4dd6e76ffad2d4c65bf20f81274","prot":"public","name":"RSMI_TEMP_CRIT_MIN","initializer":null,"briefdescription":"","detaileddescription":"Temperature critical min value, typically lower than corresponding temperature minimum values."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a48e49fe2e795c92b93885d7548f1970c","prot":"public","name":"RSMI_TEMP_CRIT_MIN_HYST","initializer":null,"briefdescription":"","detaileddescription":"Temperature hysteresis value for critical minimum limit. (This is an absolute temperature, not a delta)."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2add477d1ce57b94ca5a4e5ef99244eaad","prot":"public","name":"RSMI_TEMP_OFFSET","initializer":null,"briefdescription":"","detaileddescription":"Temperature offset which is added to the temperature reading by the chip."},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a10368c7b7a392046757aad6ecf41fc06","prot":"public","name":"RSMI_TEMP_LOWEST","initializer":null,"briefdescription":"Historical minimum temperature.","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2ad2e90b8384a20db70c70c671c7c7ee4e","prot":"public","name":"RSMI_TEMP_HIGHEST","initializer":null,"briefdescription":"Historical maximum temperature.","detaileddescription":""},{"id":"rocm__smi_8h_1ga90d27331dd58d5552cd08c5a37bbece2a8753476dcdf2b058b7a6155b59e3746c","prot":"public","name":"RSMI_TEMP_LAST","initializer":"= RSMI_TEMP_HIGHEST","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1af4ad084051b497ddf4afccc50639de7e","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_temperature_type_t","briefdescription":"This enumeration is used to indicate from which part of the device a temperature reading should be obtained.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea3e5b0684641d7c56088d40f11bc6c7b9","prot":"public","name":"RSMI_TEMP_TYPE_FIRST","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea95bdaea26e596c19c76f5a0d8f0b8564","prot":"public","name":"RSMI_TEMP_TYPE_EDGE","initializer":"= RSMI_TEMP_TYPE_FIRST","briefdescription":"Edge GPU temperature.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ead965d5428f70f730e0948744e972a622","prot":"public","name":"RSMI_TEMP_TYPE_JUNCTION","initializer":null,"briefdescription":"","detaileddescription":"Junction\/hotspot temperature"},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea6c0b0742ee29a0ae34361be318acdc10","prot":"public","name":"RSMI_TEMP_TYPE_MEMORY","initializer":null,"briefdescription":"VRAM temperature.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea36325bba87fa08ba0aeea0100605a7da","prot":"public","name":"RSMI_TEMP_TYPE_HBM_0","initializer":null,"briefdescription":"HBM temperature instance 0.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea5cdd177435bca6c8d02b778018743965","prot":"public","name":"RSMI_TEMP_TYPE_HBM_1","initializer":null,"briefdescription":"HBM temperature instance 1.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea277bb91e662a0f003f446c9880db6fcd","prot":"public","name":"RSMI_TEMP_TYPE_HBM_2","initializer":null,"briefdescription":"HBM temperature instance 2.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7eadaa84a4e777058fbe54719e1aa67d68a","prot":"public","name":"RSMI_TEMP_TYPE_HBM_3","initializer":null,"briefdescription":"HBM temperature instance 3.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea04dc2ea93bbd80582d4310d1e2180dd7","prot":"public","name":"RSMI_TEMP_TYPE_LAST","initializer":"= RSMI_TEMP_TYPE_HBM_3","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaf4ad084051b497ddf4afccc50639de7ea71e56bd66aabc696a64aa391228d5de2","prot":"public","name":"RSMI_TEMP_TYPE_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"Invalid type.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a0bbea6d5ebfdfd68bc0c3e791c850192","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_activity_metric_t","briefdescription":"Activity (Utilization) Metrics. This enum is used to identify various activity metrics.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga0bbea6d5ebfdfd68bc0c3e791c850192aa30c520593486581824c6e3b07962674","prot":"public","name":"RSMI_ACTIVITY_GFX","initializer":"= (0x1 << 0)","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga0bbea6d5ebfdfd68bc0c3e791c850192a8ae00cf676ed297fe1c14ba46f1cac83","prot":"public","name":"RSMI_ACTIVITY_UMC","initializer":"= (0x1 << 1)","briefdescription":"memory controller","detaileddescription":""},{"id":"rocm__smi_8h_1ga0bbea6d5ebfdfd68bc0c3e791c850192a9b760b3ec027aea07c077f329409411d","prot":"public","name":"RSMI_ACTIVITY_MM","initializer":"= (0x1 << 2)","briefdescription":"UVD or VCN.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a4560bd75a4e9010181b40f746ce92cb3","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_voltage_metric_t","briefdescription":"Voltage Metrics. This enum is used to identify various Volatge metrics. Corresponding values will be in millivolt.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a530e6ae9924bd5fc70e91913d58a78f0","prot":"public","name":"RSMI_VOLT_CURRENT","initializer":"= 0x0","briefdescription":"Voltage current value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3ab019ea18d689a90143c7f2fd22f63e5e","prot":"public","name":"RSMI_VOLT_FIRST","initializer":"= RSMI_VOLT_CURRENT","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3abe4c202bad48af2046275c0a6adf3941","prot":"public","name":"RSMI_VOLT_MAX","initializer":null,"briefdescription":"Voltage max value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a42cfba78d594e9959e0dbc20bbda217b","prot":"public","name":"RSMI_VOLT_MIN_CRIT","initializer":null,"briefdescription":"Voltage critical min value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a90f8efe5c73b2316e1e5a02d6dc3e35f","prot":"public","name":"RSMI_VOLT_MIN","initializer":null,"briefdescription":"Voltage min value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a44c3661651e2651b1bf4752e9e3ec13b","prot":"public","name":"RSMI_VOLT_MAX_CRIT","initializer":null,"briefdescription":"Voltage critical max value.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3ab39c9ecddc9710206a56f7ff07667894","prot":"public","name":"RSMI_VOLT_AVERAGE","initializer":null,"briefdescription":"Average voltage.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a0dbe2bbbc50365f72e742fe2aa927a3e","prot":"public","name":"RSMI_VOLT_LOWEST","initializer":null,"briefdescription":"Historical minimum voltage.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3ac6485a19546592b749b8894fea2634d1","prot":"public","name":"RSMI_VOLT_HIGHEST","initializer":null,"briefdescription":"Historical maximum voltage.","detaileddescription":""},{"id":"rocm__smi_8h_1ga4560bd75a4e9010181b40f746ce92cb3a97d02a60bfd34e98f4fb117b4c7d765d","prot":"public","name":"RSMI_VOLT_LAST","initializer":"= RSMI_VOLT_HIGHEST","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a685204d2e1d213b0cd4687a3d06ee94b","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_voltage_type_t","briefdescription":"This ennumeration is used to indicate which type of voltage reading should be obtained.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga685204d2e1d213b0cd4687a3d06ee94ba6695c1bc40c2058cc714e970083abf8c","prot":"public","name":"RSMI_VOLT_TYPE_FIRST","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga685204d2e1d213b0cd4687a3d06ee94ba1ea70cdb639ef7082afbf1ae654c253a","prot":"public","name":"RSMI_VOLT_TYPE_VDDGFX","initializer":"= RSMI_VOLT_TYPE_FIRST","briefdescription":"","detaileddescription":"Vddgfx GPU voltage"},{"id":"rocm__smi_8h_1ga685204d2e1d213b0cd4687a3d06ee94ba97f59bff259e57befb18842a1822be2a","prot":"public","name":"RSMI_VOLT_TYPE_LAST","initializer":"= RSMI_VOLT_TYPE_VDDGFX","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga685204d2e1d213b0cd4687a3d06ee94ba8c71bd3ff5c2ec7fcb64c7e62b8ea8cb","prot":"public","name":"RSMI_VOLT_TYPE_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"Invalid type.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1aa9a2e4458b8f9184b9fd4a9a4d97fb21","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_power_profile_preset_masks_t","briefdescription":"Pre-set Profile Selections. These bitmasks can be AND'd with the  returned from  to determine which power profiles are supported by the system.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a996b47327b0560fdbe0f4b71098df728","prot":"public","name":"RSMI_PWR_PROF_PRST_CUSTOM_MASK","initializer":"= 0x1","briefdescription":"Custom Power Profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a52e2211dd080689386e5a8663b992de5","prot":"public","name":"RSMI_PWR_PROF_PRST_VIDEO_MASK","initializer":"= 0x2","briefdescription":"Video Power Profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a9ce958d46d2d8ab4bf3688ea6ced596a","prot":"public","name":"RSMI_PWR_PROF_PRST_POWER_SAVING_MASK","initializer":"= 0x4","briefdescription":"Power Saving Profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21ab5a7723434c74688329a95438b44b4a8","prot":"public","name":"RSMI_PWR_PROF_PRST_COMPUTE_MASK","initializer":"= 0x8","briefdescription":"Compute Saving Profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a7f906fb05525d1513a1077e5050c58c3","prot":"public","name":"RSMI_PWR_PROF_PRST_VR_MASK","initializer":"= 0x10","briefdescription":"VR Power Profile.","detaileddescription":"3D Full Screen Power Profile"},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21acd93392837cf1ab6c1a07cc652e2f17f","prot":"public","name":"RSMI_PWR_PROF_PRST_3D_FULL_SCR_MASK","initializer":"= 0x20","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21ad5d2913bda932441b7e0bc18948816b7","prot":"public","name":"RSMI_PWR_PROF_PRST_BOOTUP_DEFAULT","initializer":"= 0x40","briefdescription":"Default Boot Up Profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a125881c5310729be96fcb7ee4acd5fe6","prot":"public","name":"RSMI_PWR_PROF_PRST_LAST","initializer":"= RSMI_PWR_PROF_PRST_BOOTUP_DEFAULT","briefdescription":"Invalid power profile.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa9a2e4458b8f9184b9fd4a9a4d97fb21a8509185f0de9cd407f4e24311b03a578","prot":"public","name":"RSMI_PWR_PROF_PRST_INVALID","initializer":"= 0xFFFFFFFFFFFFFFFF","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1aaadd2e18c2932088d42f66e3da216b38","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_gpu_block_t","briefdescription":"This enum is used to identify different GPU blocks.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a5c34c4aba1ea3ef103d06dd5f26ff170","prot":"public","name":"RSMI_GPU_BLOCK_INVALID","initializer":"= 0x0000000000000000","briefdescription":"","detaileddescription":"Used to indicate an invalid block"},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a0f10531b35415107c6bf23a8edfb7dd7","prot":"public","name":"RSMI_GPU_BLOCK_FIRST","initializer":"= 0x0000000000000001","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38aa904b391df4c61c6d148c6f5a22ebd85","prot":"public","name":"RSMI_GPU_BLOCK_UMC","initializer":"= RSMI_GPU_BLOCK_FIRST","briefdescription":"UMC block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38afa627ffb6faac7c29e8782ea8de74dc2","prot":"public","name":"RSMI_GPU_BLOCK_SDMA","initializer":"= 0x0000000000000002","briefdescription":"SDMA block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a2c1463aa9db9f5cdda1a3edf3ff001c9","prot":"public","name":"RSMI_GPU_BLOCK_GFX","initializer":"= 0x0000000000000004","briefdescription":"GFX block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a2e9fe20afcceb33fe3cef83d2914f8a7","prot":"public","name":"RSMI_GPU_BLOCK_MMHUB","initializer":"= 0x0000000000000008","briefdescription":"MMHUB block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a15b2520841c7bfd4935a696a3775c163","prot":"public","name":"RSMI_GPU_BLOCK_ATHUB","initializer":"= 0x0000000000000010","briefdescription":"ATHUB block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38af2ca41049114b0e7677c1bbc2702f968","prot":"public","name":"RSMI_GPU_BLOCK_PCIE_BIF","initializer":"= 0x0000000000000020","briefdescription":"PCIE_BIF block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a5099d8a8a1d3dad490f43fb9cf0d57ef","prot":"public","name":"RSMI_GPU_BLOCK_HDP","initializer":"= 0x0000000000000040","briefdescription":"HDP block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a842bb0772120e75254ef4ed8e8f15a14","prot":"public","name":"RSMI_GPU_BLOCK_XGMI_WAFL","initializer":"= 0x0000000000000080","briefdescription":"XGMI block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a572e633290121a64991d908b3074d72b","prot":"public","name":"RSMI_GPU_BLOCK_DF","initializer":"= 0x0000000000000100","briefdescription":"DF block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a0db15c0a0d77ec31a5532de7c841bbfb","prot":"public","name":"RSMI_GPU_BLOCK_SMN","initializer":"= 0x0000000000000200","briefdescription":"SMN block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a5b4baf94736544f970b46a36cbab5a9c","prot":"public","name":"RSMI_GPU_BLOCK_SEM","initializer":"= 0x0000000000000400","briefdescription":"SEM block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38af3c9b815174860d1eac6d88d99ba4939","prot":"public","name":"RSMI_GPU_BLOCK_MP0","initializer":"= 0x0000000000000800","briefdescription":"MP0 block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a78d7eec61c8e2a721ce6bc9124451266","prot":"public","name":"RSMI_GPU_BLOCK_MP1","initializer":"= 0x0000000000001000","briefdescription":"MP1 block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a33f2803f653eeecee24200a736f47770","prot":"public","name":"RSMI_GPU_BLOCK_FUSE","initializer":"= 0x0000000000002000","briefdescription":"Fuse block.","detaileddescription":""},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38ac85eae7107c4f0acf31960025d9cf6a2","prot":"public","name":"RSMI_GPU_BLOCK_LAST","initializer":"= RSMI_GPU_BLOCK_FUSE","briefdescription":"for supported blocks","detaileddescription":"The highest bit position"},{"id":"rocm__smi_8h_1gaaadd2e18c2932088d42f66e3da216b38a526bb096d37162f2961a0d1de3e1f3b4","prot":"public","name":"RSMI_GPU_BLOCK_RESERVED","initializer":"= 0x8000000000000000","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a94fcca9e850381733922d9cadd6af386","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_ras_err_state_t","briefdescription":"The current ECC state.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386afae2a3fc5b305afa87bddfca0ca3ad15","prot":"public","name":"RSMI_RAS_ERR_STATE_NONE","initializer":"= 0","briefdescription":"No current errors.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a53160cf365effa36e8ba13839913d907","prot":"public","name":"RSMI_RAS_ERR_STATE_DISABLED","initializer":null,"briefdescription":"ECC is disabled.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a65a306b1344a43cb26756d16844e416a","prot":"public","name":"RSMI_RAS_ERR_STATE_PARITY","initializer":null,"briefdescription":"ECC errors present, but type unknown.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a6dd90d9cef780c05d1ad9cfa5827a96a","prot":"public","name":"RSMI_RAS_ERR_STATE_SING_C","initializer":null,"briefdescription":"Single correctable error.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a05cec1f810c06227e4caa2b8d6d327d1","prot":"public","name":"RSMI_RAS_ERR_STATE_MULT_UC","initializer":null,"briefdescription":"Multiple uncorrectable errors.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a4f26c80522e0eab966866c96993c5de8","prot":"public","name":"RSMI_RAS_ERR_STATE_POISON","initializer":null,"briefdescription":"","detaileddescription":"Firmware detected error and isolated page. Treat as uncorrectable."},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386a8552f088c708142c13530f363e5b2b58","prot":"public","name":"RSMI_RAS_ERR_STATE_ENABLED","initializer":null,"briefdescription":"ECC is enabled.","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386ac24df7462b7ccd57b6768ac56aaee9da","prot":"public","name":"RSMI_RAS_ERR_STATE_LAST","initializer":"= RSMI_RAS_ERR_STATE_ENABLED","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga94fcca9e850381733922d9cadd6af386ae5351a64eb527c6690694e0df52ce158","prot":"public","name":"RSMI_RAS_ERR_STATE_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1aa968142462154b449827a90296dc46e9","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_memory_type_t","briefdescription":"Types of memory.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaa968142462154b449827a90296dc46e9a92c6c37d2efa1a573e0b75fdd44c381a","prot":"public","name":"RSMI_MEM_TYPE_FIRST","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gaa968142462154b449827a90296dc46e9a1d4fda3cacd38735641f1e99f4caff4f","prot":"public","name":"RSMI_MEM_TYPE_VRAM","initializer":"= RSMI_MEM_TYPE_FIRST","briefdescription":"VRAM memory.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa968142462154b449827a90296dc46e9a654df2646a6ce6621c784fb1008e0f50","prot":"public","name":"RSMI_MEM_TYPE_VIS_VRAM","initializer":null,"briefdescription":"VRAM memory that is visible.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa968142462154b449827a90296dc46e9a596f3c013227ec82e4ebb05953d172ad","prot":"public","name":"RSMI_MEM_TYPE_GTT","initializer":null,"briefdescription":"GTT memory.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa968142462154b449827a90296dc46e9a1317e9252c6f99f619ae780123f2cbc7","prot":"public","name":"RSMI_MEM_TYPE_LAST","initializer":"= RSMI_MEM_TYPE_GTT","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1aa2f9eb09e769d9f5fcfbf1069159c5e4","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_freq_ind_t","briefdescription":"The values of this enum are used as frequency identifiers.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaa2f9eb09e769d9f5fcfbf1069159c5e4a359c4759d29f4454c4222df5695a8f9f","prot":"public","name":"RSMI_FREQ_IND_MIN","initializer":"= 0","briefdescription":"Index used for the minimum frequency value.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa2f9eb09e769d9f5fcfbf1069159c5e4a144e31b0eb532d1b89b1e8941ecdb20d","prot":"public","name":"RSMI_FREQ_IND_MAX","initializer":"= 1","briefdescription":"Index used for the maximum frequency value.","detaileddescription":""},{"id":"rocm__smi_8h_1gaa2f9eb09e769d9f5fcfbf1069159c5e4aa0a807f50293898193e8aba23139c9a4","prot":"public","name":"RSMI_FREQ_IND_INVALID","initializer":"= 0xFFFFFFFF","briefdescription":"An invalid frequency index.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1ab64174e15afe60ed19c4d011ceb15fa0","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_fw_block_t","briefdescription":"The values of this enum are used to identify the various firmware blocks.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a299d24f920c815a119ef7faa216a595c","prot":"public","name":"RSMI_FW_BLOCK_FIRST","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0adbf2d82ff08300281ecf579513dc7922","prot":"public","name":"RSMI_FW_BLOCK_ASD","initializer":"= RSMI_FW_BLOCK_FIRST","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ae25562356fb0bd455173783e706e7128","prot":"public","name":"RSMI_FW_BLOCK_CE","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ad625f9ee85e9655246f3b09e55c4e069","prot":"public","name":"RSMI_FW_BLOCK_DMCU","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a1718cdb32a792b6aae68dc2e538551d8","prot":"public","name":"RSMI_FW_BLOCK_MC","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ae45713990384172359839d129b5869c2","prot":"public","name":"RSMI_FW_BLOCK_ME","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a516cd074727af82161a6aeda667da47b","prot":"public","name":"RSMI_FW_BLOCK_MEC","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ab44e5f9790eb4635c55af2a833291cf3","prot":"public","name":"RSMI_FW_BLOCK_MEC2","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a01f60714f3c61ba2c4679fa543009b57","prot":"public","name":"RSMI_FW_BLOCK_MES","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0abe4d60c5c334d9fc139099aaf0aa612b","prot":"public","name":"RSMI_FW_BLOCK_MES_KIQ","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a8eb7ba10c4edaa0d9480f270a5cc11a7","prot":"public","name":"RSMI_FW_BLOCK_PFP","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ad7a9d2770dafcbaf4700fa1343b3f05a","prot":"public","name":"RSMI_FW_BLOCK_RLC","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ad540a44b045d230cafdadaafa5068e3f","prot":"public","name":"RSMI_FW_BLOCK_RLC_SRLC","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a6c131985aad93ab994ea3d9d29190fd9","prot":"public","name":"RSMI_FW_BLOCK_RLC_SRLG","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ab05f4bae49ba5ba31e63d1ba92f4b629","prot":"public","name":"RSMI_FW_BLOCK_RLC_SRLS","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0afcd53a854ee14d80e9ed1a4f7b28d2f4","prot":"public","name":"RSMI_FW_BLOCK_SDMA","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a4acbf86e35d36629453222c18a7cc079","prot":"public","name":"RSMI_FW_BLOCK_SDMA2","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a35c384b15b504d2208ab2589fa36b7a6","prot":"public","name":"RSMI_FW_BLOCK_SMC","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a11bfcfb7db2e9fb48e1d4c32c978ff9d","prot":"public","name":"RSMI_FW_BLOCK_SOS","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a63a6b308ded67acd44d5da77aa5d9819","prot":"public","name":"RSMI_FW_BLOCK_TA_RAS","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a8b6a233356cbe19d022a9593c5e8ce37","prot":"public","name":"RSMI_FW_BLOCK_TA_XGMI","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0a65fdbe1554d55e7ba33512388affbc0e","prot":"public","name":"RSMI_FW_BLOCK_UVD","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ad4e46d56cd75d11c2c884619919a3d79","prot":"public","name":"RSMI_FW_BLOCK_VCE","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0aa6a6dda69a4941f7e6a5f08542468e53","prot":"public","name":"RSMI_FW_BLOCK_VCN","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1gab64174e15afe60ed19c4d011ceb15fa0ae76ad477de51e962e393694eda9a266c","prot":"public","name":"RSMI_FW_BLOCK_LAST","initializer":"= RSMI_FW_BLOCK_VCN","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a60d5232691879a48ca66c44a929ce532","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_xgmi_status_t","briefdescription":"XGMI Status.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga60d5232691879a48ca66c44a929ce532aae272d6db7201d6e84ff6dcb1f10fe61","prot":"public","name":"RSMI_XGMI_STATUS_NO_ERRORS","initializer":"= 0","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga60d5232691879a48ca66c44a929ce532a4a7d62c58c06d8b3e82d99ec389162b4","prot":"public","name":"RSMI_XGMI_STATUS_ERROR","initializer":null,"briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga60d5232691879a48ca66c44a929ce532ac403fbe7925bbe2573a5fda0650b35c3","prot":"public","name":"RSMI_XGMI_STATUS_MULTIPLE_ERRORS","initializer":null,"briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a1260f1b409c98f4f243cbdc7f8ef09e0","prot":"public","static":"no","strong":"no","type":null,"name":"rsmi_memory_page_status_t","briefdescription":"Reserved Memory Page States.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga1260f1b409c98f4f243cbdc7f8ef09e0ad149ce9ce39923d1c5b74a2727502e6f","prot":"public","name":"RSMI_MEM_PAGE_STATUS_RESERVED","initializer":"= 0","briefdescription":"","detaileddescription":"Reserved. This gpu page is reserved and not available for use"},{"id":"rocm__smi_8h_1ga1260f1b409c98f4f243cbdc7f8ef09e0a93ceccb5357188eba64f5706f0f755fe","prot":"public","name":"RSMI_MEM_PAGE_STATUS_PENDING","initializer":null,"briefdescription":"","detaileddescription":"Pending. This gpu page is marked as bad and will be marked reserved at the next window."},{"id":"rocm__smi_8h_1ga1260f1b409c98f4f243cbdc7f8ef09e0a733ab08fa58e64c5fe42c2a43142d249","prot":"public","name":"RSMI_MEM_PAGE_STATUS_UNRESERVABLE","initializer":null,"briefdescription":"Unable to reserve this page.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a2314d4a4cad5cbc70ac51148aff4f02e","prot":"public","static":"no","strong":"no","type":null,"name":"_RSMI_IO_LINK_TYPE","briefdescription":"Types for IO Link.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga2314d4a4cad5cbc70ac51148aff4f02eabb8db9493b33e22ce720c0338efce35d","prot":"public","name":"RSMI_IOLINK_TYPE_UNDEFINED","initializer":"= 0","briefdescription":"unknown type.","detaileddescription":""},{"id":"rocm__smi_8h_1ga2314d4a4cad5cbc70ac51148aff4f02eabfe4beca86a5d69575eddea655a920a9","prot":"public","name":"RSMI_IOLINK_TYPE_PCIEXPRESS","initializer":null,"briefdescription":"PCI Express.","detaileddescription":""},{"id":"rocm__smi_8h_1ga2314d4a4cad5cbc70ac51148aff4f02eab19de4182751f063b18d224c0d5030ae","prot":"public","name":"RSMI_IOLINK_TYPE_XGMI","initializer":null,"briefdescription":"XGMI.","detaileddescription":""},{"id":"rocm__smi_8h_1ga2314d4a4cad5cbc70ac51148aff4f02eaf192f52c55296e23eabf785a366ff82f","prot":"public","name":"RSMI_IOLINK_TYPE_NUMIOLINKTYPES","initializer":null,"briefdescription":"Number of IO Link types.","detaileddescription":""},{"id":"rocm__smi_8h_1ga2314d4a4cad5cbc70ac51148aff4f02eae29b34bd4e301fdf576c4e46ff8ab090","prot":"public","name":"RSMI_IOLINK_TYPE_SIZE","initializer":"= 0xFFFFFFFF","briefdescription":"Max of IO Link types.","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1a1b6e8fa06718717a63b86bc024f7a474","prot":"public","static":"no","strong":"no","type":null,"name":"RSMI_UTILIZATION_COUNTER_TYPE","briefdescription":"The utilization counter type.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1ga1b6e8fa06718717a63b86bc024f7a474ac73576ffc7be5b88cbaec2e8e2864f31","prot":"public","name":"RSMI_UTILIZATION_COUNTER_FIRST","initializer":"= 0","briefdescription":"GFX Activity.","detaileddescription":""},{"id":"rocm__smi_8h_1ga1b6e8fa06718717a63b86bc024f7a474a7eb9e0c3f9c9ade7bb97694ebb4eac33","prot":"public","name":"RSMI_COARSE_GRAIN_GFX_ACTIVITY","initializer":"= RSMI_UTILIZATION_COUNTER_FIRST","briefdescription":"","detaileddescription":""},{"id":"rocm__smi_8h_1ga1b6e8fa06718717a63b86bc024f7a474ac1fdedf0693a4db8de7dc3ee62b92ebf","prot":"public","name":"RSMI_COARSE_GRAIN_MEM_ACTIVITY","initializer":null,"briefdescription":"Memory Activity.","detaileddescription":""},{"id":"rocm__smi_8h_1ga1b6e8fa06718717a63b86bc024f7a474afc45e47a369651dc7e043f494bffdedb","prot":"public","name":"RSMI_UTILIZATION_COUNTER_LAST","initializer":"= RSMI_COARSE_GRAIN_MEM_ACTIVITY","briefdescription":"","detaileddescription":""}]},{"kind":"enum","id":"rocm__smi_8h_1af1e9cebc03e526a1f900365bfcd52f99","prot":"public","static":"no","strong":"no","type":null,"name":"RSMI_POWER_TYPE","briefdescription":"Power types.","detaileddescription":null,"inbodydescription":null,"initializer":null,"enumvalue":[{"id":"rocm__smi_8h_1gaf1e9cebc03e526a1f900365bfcd52f99a6525432625b08b89fe3db51c256f0744","prot":"public","name":"RSMI_AVERAGE_POWER","initializer":"= 0","briefdescription":"Average Power.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf1e9cebc03e526a1f900365bfcd52f99ac5d977f27e345227e37f7cb5907ec82b","prot":"public","name":"RSMI_CURRENT_POWER","initializer":null,"briefdescription":"Current \/ Instant Power.","detaileddescription":""},{"id":"rocm__smi_8h_1gaf1e9cebc03e526a1f900365bfcd52f99a799b0ddadd37eb6fe67e520005dfcd5b","prot":"public","name":"RSMI_INVALID_POWER","initializer":"= 0xFFFFFFFF","briefdescription":"Invalid \/ Undetected Power.","detaileddescription":""}]},{"kind":"typedef","id":"rocm__smi_8h_1ada2596ec3402121156528f9614d336ef","prot":"public","static":"no","type":"uintptr_t","definition":"typedef uintptr_t rsmi_event_handle_t","argsstring":null,"name":"rsmi_event_handle_t","briefdescription":"Handle to performance event counter.","detaileddescription":"Event counter types","inbodydescription":null,"initializer":null},{"kind":"typedef","id":"rocm__smi_8h_1adce0851e7935cc927a8a5e837ecbe812","prot":"public","static":"no","type":"uint64_t","definition":"typedef uint64_t rsmi_bit_field_t","argsstring":null,"name":"rsmi_bit_field_t","briefdescription":"Bitfield used in various RSMI calls.","detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"rocm__smi_8h_1ac77ea13edc983b2733334e2f8ac40a81","prot":"public","static":"no","type":"enum","definition":"typedef enum _RSMI_IO_LINK_TYPE RSMI_IO_LINK_TYPE","argsstring":null,"name":"RSMI_IO_LINK_TYPE","briefdescription":"Types for IO Link.","detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"rocm__smi_8h_1a0dd6b2561ebeda5be65ceb0349210d8f","prot":"public","static":"no","type":"struct rsmi_func_id_iter_handle *","definition":"typedef struct rsmi_func_id_iter_handle* rsmi_func_id_iter_handle_t","argsstring":null,"name":"rsmi_func_id_iter_handle_t","briefdescription":"Opaque handle to function-support object.","detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"rocm__smi_8h_1ae9588cc5304b8640fbe314570754bd86","prot":"public","static":"no","type":"union","definition":"typedef union id rsmi_func_id_value_t","argsstring":null,"name":"rsmi_func_id_value_t","briefdescription":"This union holds the value of an . The value may be a function name, or an ennumerated variant value of types such as , , etc.","detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga3eba939e0b9ebd015ad74c3df5467113","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricTempHbm_t[RSMI_NUM_HBM_INSTANCES]","argsstring":"[RSMI_NUM_HBM_INSTANCES]","name":"GPUMetricTempHbm_t","briefdescription":null,"detaileddescription":"Metric multi-valued counter types","inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gac477348c810cfce3cfa7c0d15ad8f907","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricVcnActivity_t[RSMI_MAX_NUM_VCNS]","argsstring":"[RSMI_MAX_NUM_VCNS]","name":"GPUMetricVcnActivity_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga7ae092a12d224f74635e4a0f26e2805c","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricJpegActivity_t[RSMI_MAX_NUM_JPEG_ENGS]","argsstring":"[RSMI_MAX_NUM_JPEG_ENGS]","name":"GPUMetricJpegActivity_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gae584e8a28cf43be0f6041f2802a8dd4c","prot":"public","static":"no","type":"uint64_t","definition":"typedef uint64_t GPUMetricXgmiReadDataAcc_t[RSMI_MAX_NUM_XGMI_LINKS]","argsstring":"[RSMI_MAX_NUM_XGMI_LINKS]","name":"GPUMetricXgmiReadDataAcc_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga810adbd48197678137b9a0279bcc66ff","prot":"public","static":"no","type":"uint64_t","definition":"typedef uint64_t GPUMetricXgmiWriteDataAcc_t[RSMI_MAX_NUM_XGMI_LINKS]","argsstring":"[RSMI_MAX_NUM_XGMI_LINKS]","name":"GPUMetricXgmiWriteDataAcc_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gab0a93bc0949ab898c379d9fa0988ada7","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrGfxClk_t[RSMI_MAX_NUM_GFX_CLKS]","argsstring":"[RSMI_MAX_NUM_GFX_CLKS]","name":"GPUMetricCurrGfxClk_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga716689f299e9b3fadc639445df2732ab","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrSocClk_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrSocClk_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gafee46875174f8b107cf8ad4ded9907bd","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrVClk0_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrVClk0_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga5be7d659fa12d9524599e373b9185813","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrDClk0_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrDClk0_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"function","id":"group__InitShutAdmin_1ga2f427b6a84e2406daeb322cf77a7b0ca","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint64_t","declname":"init_flags","direction":"in","parameterdescription":"Bit flags that tell SMI how to initialze. Values of rsmi_init_flags_t may be OR'd together and passed through init_flags to modify how RSMI initializes."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_init","argsstring":"(uint64_t init_flags)","name":"rsmi_init","briefdescription":"Initialize ROCm SMI.","detaileddescription":"When called, this initializes internal data structures, including those corresponding to sources of information that SMI provides.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__InitShutAdmin_1ga354d175a5678aec1f3b2aa363f560940","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"void","declname":""}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_shut_down","argsstring":"(void)","name":"rsmi_shut_down","briefdescription":"Shutdown ROCm SMI.","detaileddescription":"Do any necessary clean up.","inbodydescription":null,"initializer":null,"returns":null},{"kind":"function","id":"group__IDQuer_1ga320c921a8906c7c23b593f2e01afde7c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t *","declname":"num_devices","direction":"inout","parameterdescription":"Caller provided pointer to uint32_t. Upon successful call, the value num_devices will contain the number of monitor devices."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_num_monitor_devices","argsstring":"(uint32_t *num_devices)","name":"rsmi_num_monitor_devices","briefdescription":"Get the number of devices that have monitor information.","detaileddescription":"The number of devices which have monitors is returned. Monitors are referenced by the index which can be between 0 and - 1.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1gad9e05f1a9acc1a2095ac956d6704f412","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_id_get","briefdescription":"Get the device id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device id value to the uint64_t pointed to by . This ID is an identification of the type of device, so calling this function for different devices will give the same value if they are kind of device. Consequently, this function should not be used to distinguish one device from another. should be used to get a unique identifier.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gae0ce7ceb9dcb750814590eed083d3ca5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"revision","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device revision will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_revision_get","argsstring":"(uint32_t dv_ind, uint16_t *revision)","name":"rsmi_dev_revision_get","briefdescription":"Get the device revision associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t to which the revision will be written","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1ga71758627d0bf7a32b1396e8858005309","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"sku","direction":"inout","parameterdescription":"a pointer to char to which the sku will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_sku_get","argsstring":"(uint32_t dv_ind, char *sku)","name":"rsmi_dev_sku_get","briefdescription":"Get the SKU for a desired device associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a char , this function will attempt to obtain the SKU from the Product Information FRU chip, present on server ASICs. It will write the sku value to the char array pointed to by .If this parameter is nullptr, this function will return if the function is supported with the provided, arguments and if it is not supported with the provided arguments.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gaff4fc1b02761f4dd991a6326e35b7123","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device vendor id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vendor_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_vendor_id_get","briefdescription":"Get the device vendor id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device vendor id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1ga15f681e22f87270434f753542c8c46b3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_name_get","briefdescription":"Get the name string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the device (up to characters) to the buffer .If the integer ID associated with the device is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex device ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1gac7be897fab33a50b65b483b5c4c7c828","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"brand","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the brand will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer brand."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_brand_get","argsstring":"(uint32_t dv_ind, char *brand, uint32_t len)","name":"rsmi_dev_brand_get","briefdescription":"Get the brand string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the brand of the device (up to characters) to the buffer .If the sku associated with the device is not found as one of the values contained within rsmi_dev_brand_get, then this function will return the device marketing name as a string instead of the brand name.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1gac6e9bc242fa4fa7c641ec91adc8bf8aa","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vendor_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_vendor_name_get","briefdescription":"Get the name string for a give vendor ID.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the vendor (up to characters) buffer . The may be a device vendor or subsystem vendor ID.If the integer ID associated with the vendor is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex vendor ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga5664a8d8dbc8f3bd1a1aa0f3565b3973","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"brand","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the vram vendor will be written"},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer brand."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vram_vendor_get","argsstring":"(uint32_t dv_ind, char *brand, uint32_t len)","name":"rsmi_dev_vram_vendor_get","briefdescription":"Get the vram vendor string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the vram vendor of the device (up to characters) to the buffer .If the vram vendor for the device is not found as one of the values contained within rsmi_dev_vram_vendor_get, then this function will return the string 'unknown' instead of the vram vendor.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1gabe9c502ea30fbe6d66372f67cff313b3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"serial_num","direction":"inout","parameterdescription":"a pointer to caller-provided memory to which the serial number will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer serial_num."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_serial_number_get","argsstring":"(uint32_t dv_ind, char *serial_num, uint32_t len)","name":"rsmi_dev_serial_number_get","briefdescription":"Get the serial number string for a device.","detaileddescription":"Given a device index , a pointer to a buffer of chars , and the length of the provided buffer , this function will write the serial number string (up to characters) to the buffer pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga9f28d6a147d605085a0ff832eb1ed7df","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the subsystem device id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_subsystem_id_get","briefdescription":"Get the subsystem device id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the subsystem device id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gadd58554a73a901f911ed705fac6d6dc1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_subsystem_name_get","briefdescription":"Get the name string for the device subsytem.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the device subsystem (up to characters) to the buffer .If the integer ID associated with the sub-system is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex sub-system ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga7231546b6feea52f39aa08e847efdfe6","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"minor","direction":"inout","parameterdescription":"a pointer to a uint32_t into which minor number will be copied"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_drm_render_minor_get","argsstring":"(uint32_t dv_ind, uint32_t *minor)","name":"rsmi_dev_drm_render_minor_get","briefdescription":"Get the drm minor number associated with this device.","detaileddescription":"Given a device index , find its render device file \/dev\/dri\/renderDN where N corresponds to its minor number.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_INIT_ERRORif failed to get minor number during initialization. RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gae3ce7d0f046867c9a9e3710018601c2b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device subsystem vendor id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_vendor_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_subsystem_vendor_id_get","briefdescription":"Get the device subsystem vendor id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device subsystem vendor id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1ga1eb4b9e02bfa817a2848530f93e58f3b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the unique ID of the GPU is written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_unique_id_get","argsstring":"(uint32_t dv_ind, uint64_t *id)","name":"rsmi_dev_unique_id_get","briefdescription":"Get Unique ID.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the unique ID of the GPU pointed to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gaab5f890bafa0a0e7fb596ca8974e4179","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_physical_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_xgmi_physical_id_get","briefdescription":"Get the XGMI physical id associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t to which the XGMI physical id will be written","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__PCIeQuer_1ga4d8c9b4115cfb5451dff297e7afec2e7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_pcie_bandwidth_t *","declname":"bandwidth","direction":"inout","parameterdescription":"a pointer to a caller provided rsmi_pcie_bandwidth_t structure to which the frequency information will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_bandwidth_get","argsstring":"(uint32_t dv_ind, rsmi_pcie_bandwidth_t *bandwidth)","name":"rsmi_dev_pci_bandwidth_get","briefdescription":"Get the list of possible PCIe bandwidths that are available.","detaileddescription":"Given a device index and a pointer to a to an structure , this function will fill in with the possible T\/s values and associated number of lanes, and indication of the current selection.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_UNEXPECTED_DATAData read or provided was not as expected"},{"kind":"function","id":"group__PCIeQuer_1gadcb3ec02149215346224d57d0002f9e2","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"bdfid","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device bdfid value will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_id_get","argsstring":"(uint32_t dv_ind, uint64_t *bdfid)","name":"rsmi_dev_pci_id_get","briefdescription":"Get the unique PCI device identifier associated for a device.","detaileddescription":"Give a device index and a pointer to a uint64_t , this function will write the Bus\/Device\/Function PCI identifier (BDFID) associated with device to the value pointed to by .The format of will be as follows:","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PCIeQuer_1ga97aa4ef153b3a01be39fb15ad60e0dc6","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"int32_t *","declname":"numa_node","direction":"inout","parameterdescription":"pointer to location where NUMA node value will be written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_numa_affinity_get","argsstring":"(uint32_t dv_ind, int32_t *numa_node)","name":"rsmi_topo_numa_affinity_get","briefdescription":"Get the NUMA node associated with a device.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will retrieve the NUMA node value associated with device and store the value at location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PCIeQuer_1ga23eeb9ad20791beb29b07db00567a5ce","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"sent","direction":"inout","parameterdescription":"a pointer to uint64_t to which the number of bytes sent will be written in 1 second. If pointer is NULL, it will be ignored."},{"type":"uint64_t *","declname":"received","direction":"inout","parameterdescription":"a pointer to uint64_t to which the number of bytes received will be written. If pointer is NULL, it will be ignored."},{"type":"uint64_t *","declname":"max_pkt_sz","direction":"inout","parameterdescription":"a pointer to uint64_t to which the maximum packet size will be written. If pointer is NULL, it will be ignored."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_throughput_get","argsstring":"(uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz)","name":"rsmi_dev_pci_throughput_get","briefdescription":"Get PCIe traffic information.","detaileddescription":"Give a device index and pointers to a uint64_t's, , and , this function will write the number of bytes sent and received in 1 second to and , respectively. The maximum possible packet size will be written to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments"},{"kind":"function","id":"group__PCIeQuer_1gaa55edbb5b39096184747ab61edf19739","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"counter","direction":"inout","parameterdescription":"a pointer to uint64_t to which the sum of the NAK's received and generated by the GPU is written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_replay_counter_get","argsstring":"(uint32_t dv_ind, uint64_t *counter)","name":"rsmi_dev_pci_replay_counter_get","briefdescription":"Get PCIe replay counter.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the sum of the number of NAK's received by the GPU and the NAK's generated by the GPU to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PCIeCont_1gae158255eeb6a73bb00b042dedb2e73d3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"bw_bitmask","direction":"in","parameterdescription":"A bitmask indicating the indices of the bandwidths that are to be enabled (1) and disabled (0). Only the lowest rsmi_frequencies_t::num_supported (of rsmi_pcie_bandwidth_t) bits of this mask are relevant."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_bandwidth_set","argsstring":"(uint32_t dv_ind, uint64_t bw_bitmask)","name":"rsmi_dev_pci_bandwidth_set","briefdescription":"Control the set of allowed PCIe bandwidths that can be used.","detaileddescription":"Given a device index and a 64 bit bitmask , this function will limit the set of allowable bandwidths. If a bit in has a value of 1, then the frequency (as ordered in an returned by ) corresponding to that bit index will be allowed.This function will change the performance level to in order to modify the set of allowable band_widths. Caller will need to set to in order to get back to default state.All bits with indices greater than or equal to the value of the field of will be ignored.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PowerQuer_1ga4c261885296806cb39fa7aa1aa68fef2","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the average power consumption will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_ave_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *power)","name":"rsmi_dev_power_ave_get","briefdescription":"Get the average power consumption of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the current average power consumption (in microwatts) to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gafb3d36d17698b411c320982cc8f8da82","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"socket_power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the current socket power will be written to. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_current_socket_power_get","argsstring":"(uint32_t dv_ind, uint64_t *socket_power)","name":"rsmi_dev_current_socket_power_get","briefdescription":"Get the current socket power (also known as instant power) of the device index provided.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the current socket power (in microwatts) to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga5c6fcd74be46ae056526c96d1a3ac09b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the current or average power will be written to. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"RSMI_POWER_TYPE *","declname":"type","direction":"inout","parameterdescription":"a pointer to RSMI_POWER_TYPE object. Returns the type of power retrieved from the device. Current power is RSMI_CURRENT_POWER and average power is RSMI_AVERAGE_POWER. If an error occurs, returns an invalid power type RSMI_INVALID_POWER."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_get","argsstring":"(uint32_t dv_ind, uint64_t *power, RSMI_POWER_TYPE *type)","name":"rsmi_dev_power_get","briefdescription":"A generic get which attempts to retieve current socket power (also known as instant power) of the device index provided, if not supported tries to get average power consumed by device. Current socket power is typically supported by newer devices, whereas average power is generally reported on older devices. This function aims to provide backwards compatability depending on device support.","detaileddescription":"Given a device index , a pointer to a uint64_t , and this function will write the current socket or average power (in microwatts) to the uint64_t pointed to by and a pointer to its RSMI_POWER_TYPE read.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga1f61b24edaca83a0e395a34c466fcf86","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the energy counter will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"float *","declname":"counter_resolution","direction":"inout","parameterdescription":"resolution of the counter power in micro Joules"},{"type":"uint64_t *","declname":"timestamp","direction":"inout","parameterdescription":"a pointer to uint64_t to which the timestamp will be written. Resolution: 1 ns."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_energy_count_get","argsstring":"(uint32_t dv_ind, uint64_t *power, float *counter_resolution, uint64_t *timestamp)","name":"rsmi_dev_energy_count_get","briefdescription":"Get the energy accumulator counter of the device with provided device index.","detaileddescription":"Given a device index , a pointer to a uint64_t , and a pointer to a uint64_t , this function will write amount of energy consumed to the uint64_t pointed to by , and the timestamp to the uint64_t pointed to by . The is an average of a short time. This function accumulates all energy consumed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gac8719065fb26a70cd6a08d6a2f8f4459","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"cap","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *cap)","name":"rsmi_dev_power_cap_get","briefdescription":"Get the cap on power which, when reached, causes the system to take action to reduce power.","detaileddescription":"When power use rises above the value , the system will take action to reduce power use. The power level returned through will be in microWatts.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga2e7a92f537eb6feaa4e6609783f7b6b7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"default_cap","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the default power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_default_get","argsstring":"(uint32_t dv_ind, uint64_t *default_cap)","name":"rsmi_dev_power_cap_default_get","briefdescription":"Get the default power cap for the device specified by .","detaileddescription":"The maximum power cap be temporarily changed by the user. However, this function always returns the default reset power cap. The power level returned through will be in microWatts.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gad551b35466b9bfdbeedbd27b470d4cea","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"max","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the maximum possible power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint64_t *","declname":"min","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the minimum possible power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_range_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min)","name":"rsmi_dev_power_cap_range_get","briefdescription":"Get the range of valid values for the power cap.","detaileddescription":"This function will return the maximum possible valid power cap and the minimum possible valid power cap","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerCont_1ga5679a8d267341b2f279b750b34cb9cde","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t","declname":"cap","direction":"in","parameterdescription":"a uint64_t that indicates the desired power cap, in microwatts"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_set","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap)","name":"rsmi_dev_power_cap_set","briefdescription":"Set the power cap value.","detaileddescription":"This function will set the power cap to the provided value . must be between the minimum and maximum power cap values set by the system, which can be obtained from .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PowerCont_1gaad21b4498141a28eb8bfb886d0fb49bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"reserved","direction":"in","parameterdescription":"Not currently used. Set to 0."},{"type":"rsmi_power_profile_preset_masks_t","declname":"profile","direction":"in","parameterdescription":"a rsmi_power_profile_preset_masks_t that hold the mask of the desired new power profile"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_profile_set","argsstring":"(uint32_t dv_ind, uint32_t reserved, rsmi_power_profile_preset_masks_t profile)","name":"rsmi_dev_power_profile_set","briefdescription":"Set the power profile.","detaileddescription":"Given a device index and a , this function will attempt to set the current profile to the provided profile. The provided profile must be one of the currently supported profiles, as indicated by a call to","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__MemQuer_1ga623b5f74bb97ba8aafa634ef6b53c085","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_type_t","declname":"mem_type","direction":"in","parameterdescription":"The type of memory for which the total amount will be found"},{"type":"uint64_t *","declname":"total","direction":"inout","parameterdescription":"a pointer to uint64_t to which the total amount of memory will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_total_get","argsstring":"(uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *total)","name":"rsmi_dev_memory_total_get","briefdescription":"Get the total amount of memory that exists.","detaileddescription":"Given a device index , a type of memory , and a pointer to a uint64_t , this function will write the total amount of memory that exists to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gac16d840cd53ade019cc81f366156f1df","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_type_t","declname":"mem_type","direction":"in","parameterdescription":"The type of memory for which the amount being used will be found"},{"type":"uint64_t *","declname":"used","direction":"inout","parameterdescription":"a pointer to uint64_t to which the amount of memory currently being used will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_usage_get","argsstring":"(uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *used)","name":"rsmi_dev_memory_usage_get","briefdescription":"Get the current memory usage.","detaileddescription":"Given a device index , a type of memory , and a pointer to a uint64_t , this function will write the amount of memory that that is currently being used to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gafdedfdf70e3691903af4f8d88f8c8eb5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"busy_percent","direction":"inout","parameterdescription":"a pointer to the uint32_t to which the busy percent will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_busy_percent_get","argsstring":"(uint32_t dv_ind, uint32_t *busy_percent)","name":"rsmi_dev_memory_busy_percent_get","briefdescription":"Get percentage of time any device memory is being used.","detaileddescription":"Given a device index , this function returns the percentage of time that any device memory is being used for the specified device.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gae87be22a7c39b4dfacff962ec2aa55b5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"num_pages","direction":"inout","parameterdescription":"a pointer to a uint32. As input, the value passed through this parameter is the number of rsmi_retired_page_record_t's that may be safely written to the memory pointed to by records. This is the limit on how many records will be written to records. On return, num_pages will contain the number of records written to records, or the number of records that could have been written if enough memory had been provided. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"rsmi_retired_page_record_t *","declname":"records","direction":"inout","parameterdescription":"A pointer to a block of memory to which the rsmi_retired_page_record_t values will be written. This value may be NULL. In this case, this function can be used to query how many records are available to read."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_reserved_pages_get","argsstring":"(uint32_t dv_ind, uint32_t *num_pages, rsmi_retired_page_record_t *records)","name":"rsmi_dev_memory_reserved_pages_get","briefdescription":"Get information about reserved (\"retired\") memory pages.","detaileddescription":"Given a device index , this function returns retired page information corresponding to the device with the provided device index . The number of retired page records is returned through . may be NULL on input. In this case, the number of records available for retrieval will be returned through .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if more records were available than allowed by the provided, allocated memory."},{"kind":"function","id":"group__PhysQuer_1gab5facb2d80e3ccc5e06da213e03e1fda","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"int64_t *","declname":"speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_rpms_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed)","name":"rsmi_dev_fan_rpms_get","briefdescription":"Get the fan speed in RPMs of the device with the specified device index and 0-based sensor index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the current fan speed in RPMs to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1gab6764103231f0d26df73ffcc1e24dc06","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"int64_t *","declname":"speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed)","name":"rsmi_dev_fan_speed_get","briefdescription":"Get the fan speed for the specified device as a value relative to .","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the current fan speed (a value between 0 and the maximum fan speed, ) to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga850b216c23c6fbb99ea2ed951b93aff1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"max_speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the maximum speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_max_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max_speed)","name":"rsmi_dev_fan_speed_max_get","briefdescription":"Get the max. fan speed of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the maximum fan speed possible to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga40e9da04e4c0cfa17a4f38b97ebc9669","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_type","direction":"in","parameterdescription":"part of device from which temperature should be obtained. This should come from the enum rsmi_temperature_type_t"},{"type":"rsmi_temperature_metric_t","declname":"metric","direction":"in","parameterdescription":"enum indicated which temperature value should be retrieved"},{"type":"int64_t *","declname":"temperature","direction":"inout","parameterdescription":"a pointer to int64_t to which the temperature will be written, in millidegrees Celcius. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_temp_metric_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_type, rsmi_temperature_metric_t metric, int64_t *temperature)","name":"rsmi_dev_temp_metric_get","briefdescription":"Get the temperature metric value for the specified metric, from the specified temperature sensor on the specified device.","detaileddescription":"Given a device index , a sensor type , a and a pointer to an int64_t , this function will write the value of the metric indicated by and to the memory location .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga2f04a6d66a11f13eb73adb403ff968a7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_voltage_type_t","declname":"sensor_type","direction":"in","parameterdescription":"part of device from which voltage should be obtained. This should come from the enum rsmi_voltage_type_t"},{"type":"rsmi_voltage_metric_t","declname":"metric","direction":"in","parameterdescription":"enum indicated which voltage value should be retrieved"},{"type":"int64_t *","declname":"voltage","direction":"inout","parameterdescription":"a pointer to int64_t to which the voltage will be written, in millivolts. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_volt_metric_get","argsstring":"(uint32_t dv_ind, rsmi_voltage_type_t sensor_type, rsmi_voltage_metric_t metric, int64_t *voltage)","name":"rsmi_dev_volt_metric_get","briefdescription":"Get the voltage metric value for the specified metric, from the specified voltage sensor on the specified device.","detaileddescription":"Given a device index , a sensor type , a and a pointer to an int64_t , this function will write the value of the metric indicated by and to the memory location .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysCont_1gacecde26a5c3bff544ff7f54686d32866","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_reset","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind)","name":"rsmi_dev_fan_reset","briefdescription":"Reset the fan to automatic driver control.","detaileddescription":"This function returns control of the fan to the system","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments"},{"kind":"function","id":"group__PhysCont_1ga70853eb646b5f73e9e0b1c4ddfa20a91","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t","declname":"speed","direction":"in","parameterdescription":"the speed to which the function will attempt to set the fan"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_set","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed)","name":"rsmi_dev_fan_speed_set","briefdescription":"Set the fan speed for the specified device with the provided speed, in RPMs.","detaileddescription":"Given a device index and a integer value indicating speed , this function will attempt to set the fan speed to . An error will be returned if the specified speed is outside the allowable range for the device. The maximum value is 255 and the minimum is 0.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfQuer_1gaeea1357c0e3b6b0a733e0cf8c7334931","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"busy_percent","direction":"inout","parameterdescription":"a pointer to the uint32_t to which the busy percent will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_busy_percent_get","argsstring":"(uint32_t dv_ind, uint32_t *busy_percent)","name":"rsmi_dev_busy_percent_get","briefdescription":"Get percentage of time device is busy doing any processing.","detaileddescription":"Given a device index , this function returns the percentage of time that the specified device is busy. The device is considered busy if any one or more of its sub-blocks are working, and idle if none of the sub-blocks are working.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaa068351a61e17e7f134e7231db697f67","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_utilization_counter_t","declname":"utilization_counters","direction":"inout","parameterdescription":"Multiple utilization counters can be retreived with a single call. The caller must allocate enough space to the utilization_counters array. The caller also needs to set valid RSMI_UTILIZATION_COUNTER_TYPE type for each element of the array. RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"count","direction":"in","parameterdescription":"The size of utilization_counters array."},{"type":"uint64_t *","declname":"timestamp","direction":"inout","parameterdescription":"The timestamp when the counter is retreived. Resolution: 1 ns."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_utilization_count_get","argsstring":"(uint32_t dv_ind, rsmi_utilization_counter_t utilization_counters[], uint32_t count, uint64_t *timestamp)","name":"rsmi_utilization_count_get","briefdescription":"Get coarse grain utilization counter of the specified device.","detaileddescription":"Given a device index , the array of the utilization counters, the size of the array, this function returns the coarse grain utilization counters and timestamp. The counter is the accumulated percentages. Every milliseconds the firmware calculates % busy count and then accumulates that value in the counter. This provides minimally invasive coarse grain GPU usage information.If the function reutrns RSMI_STATUS_SUCCESS, the counter will be set in the value field of the .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga6eb7b45aebcadec18bd2766c416a24bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_activity_metric_t","declname":"activity_metric_type","direction":"in","parameterdescription":"a metric type"},{"type":"rsmi_activity_metric_counter_t *","declname":"activity_metric_counter","direction":"inout","parameterdescription":"Multiple utilization counters can be retrieved with a single call. The caller must allocate enough space to the rsmi_activity_metric_counter_t structure."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_activity_metric_get","argsstring":"(uint32_t dv_ind, rsmi_activity_metric_t activity_metric_type, rsmi_activity_metric_counter_t *activity_metric_counter)","name":"rsmi_dev_activity_metric_get","briefdescription":"Get activity metric average utilization counter of the specified device.","detaileddescription":"Given a device index , the activity metric type, this function returns the requested utilization countersIf the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding field of the counter will be set in the value field of the activity_metric_counter_t.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaea652953f9cd509908637ddeb6357484","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"avg_activity","direction":"inout","parameterdescription":"average bandwidth utilization counters can be retrieved"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_activity_avg_mm_get","argsstring":"(uint32_t dv_ind, uint16_t *avg_activity)","name":"rsmi_dev_activity_avg_mm_get","briefdescription":"Get activity metric bandwidth average utilization counter of the specified device.","detaileddescription":"Given a device index , the activity metric type, this function returns the requested utilization countersIf the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding field of the counter will be set in the value field of the activity_metric_counter_t.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga3d5b926b493219b5cd76fb140b5a06d0","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t *","declname":"perf","direction":"inout","parameterdescription":"a pointer to rsmi_dev_perf_level_t to which the performance level will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_get","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t *perf)","name":"rsmi_dev_perf_level_get","briefdescription":"Get the performance level of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga8d56e514c463fe4d7cbe02b652397078","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"Softmax value for GFXCLK in MHz."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_perf_determinism_mode_set","argsstring":"(uint32_t dv_ind, uint64_t clkvalue)","name":"rsmi_perf_determinism_mode_set","briefdescription":"Enter performance determinism mode with provided device index.","detaileddescription":"Given a device index and this function will enable performance determinism mode, which enforces a GFXCLK frequency SoftMax limit per GPU set by the user. This prevents the GFXCLK PLL from stretching when running the same workload on different GPUS, making performance variation minimal. This call will result in the performance level of the device being .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gacaea57ee1822bee9f7d401a1fb3ebbbb","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"od","direction":"inout","parameterdescription":"a pointer to uint32_t to which the overdrive percentage will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_get","argsstring":"(uint32_t dv_ind, uint32_t *od)","name":"rsmi_dev_overdrive_level_get","briefdescription":"Get the overdrive percent associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the overdrive percentage to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaee91eae3084fdd915e364af40778dac9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"od","direction":"inout","parameterdescription":"a pointer to uint32_t to which the overdrive percentage will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_mem_overdrive_level_get","argsstring":"(uint32_t dv_ind, uint32_t *od)","name":"rsmi_dev_mem_overdrive_level_get","briefdescription":"Get the memory clock overdrive percent associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the memory overdrive percentage to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gad329e66e21b7cf8826e83177b441257a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_clk_type_t","declname":"clk_type","direction":"in","parameterdescription":"the type of clock for which the frequency is desired"},{"type":"rsmi_frequencies_t *","declname":"f","direction":"inout","parameterdescription":"a pointer to a caller provided rsmi_frequencies_t structure to which the frequency information will be written. Frequency values are in Hz. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments. If multiple current frequencies are found, a warning is shown. If no current frequency is found, it is reflected as -1. If frequencies are not read from low to high a warning is shown as well."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_clk_freq_get","argsstring":"(uint32_t dv_ind, rsmi_clk_type_t clk_type, rsmi_frequencies_t *f)","name":"rsmi_dev_gpu_clk_freq_get","briefdescription":"Get the list of possible system clock speeds of device for a specified clock type.","detaileddescription":"Given a device index , a clock type , and a pointer to a to an structure , this function will fill in with the possible clock speeds, and indication of the current clock speed selection.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATAData read or provided was not as expected"},{"kind":"function","id":"group__PerfQuer_1ga53de4eb35a0236e80157faf7678d7839","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_gpu_reset","briefdescription":"Reset the gpu associated with the device with provided device index.","detaileddescription":"Given a device index , this function will reset the GPU","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga710288709a46ab3f26202a4c634a8ae1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_od_volt_freq_data_t *","declname":"odv","direction":"inout","parameterdescription":"a pointer to an rsmi_od_volt_freq_data_t structure If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_info_get","argsstring":"(uint32_t dv_ind, rsmi_od_volt_freq_data_t *odv)","name":"rsmi_dev_od_volt_info_get","briefdescription":"This function retrieves the voltage\/frequency curve information.","detaileddescription":"Given a device index and a pointer to a structure , this function will populate . See for more details.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga7f38c8ac3868cd9cfd1ada802e891c5b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_metrics_t *","declname":"pgpu_metrics","direction":"inout","parameterdescription":"a pointer to an rsmi_gpu_metrics_t structure If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_metrics_info_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_metrics_t *pgpu_metrics)","name":"rsmi_dev_gpu_metrics_info_get","briefdescription":"This function retrieves the gpu metrics information.","detaileddescription":"Given a device index and a pointer to a structure , this function will populate . See for more details.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga0084cc9338133bcae308ef056a730ea5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"minclkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"uint64_t","declname":"maxclkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"rsmi_clk_type_t","declname":"clkType","direction":"in","parameterdescription":"RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_clk_range_set","argsstring":"(uint32_t dv_ind, uint64_t minclkvalue, uint64_t maxclkvalue, rsmi_clk_type_t clkType)","name":"rsmi_dev_clk_range_set","briefdescription":"This function sets the clock range information.","detaileddescription":"Given a device index , a minimum clock value , a maximum clock value and a clock type this function will set the sclk|mclk range","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga3b3886d657f883c81eababc53784237b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_freq_ind_t","declname":"level","direction":"in","parameterdescription":"RSMI_FREQ_IND_MIN|RSMI_FREQ_IND_MAX to set the minimum (0) or maximum (1) speed."},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"rsmi_clk_type_t","declname":"clkType","direction":"in","parameterdescription":"RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_clk_info_set","argsstring":"(uint32_t dv_ind, rsmi_freq_ind_t level, uint64_t clkvalue, rsmi_clk_type_t clkType)","name":"rsmi_dev_od_clk_info_set","briefdescription":"This function sets the clock frequency information.","detaileddescription":"Given a device index , a frequency level , a clock value and a clock type this function will set the sclk|mclk range","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaab312392d55b980848538e9461584174","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"vpoint","direction":"in","parameterdescription":"voltage point [0|1|2] on the voltage curve"},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"clock value component of voltage curve point. Frequency values are in MHz."},{"type":"uint64_t","declname":"voltvalue","direction":"in","parameterdescription":"voltage value component of voltage curve point. Voltage is in mV."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_info_set","argsstring":"(uint32_t dv_ind, uint32_t vpoint, uint64_t clkvalue, uint64_t voltvalue)","name":"rsmi_dev_od_volt_info_set","briefdescription":"This function sets 1 of the 3 voltage curve points.","detaileddescription":"Given a device index , a voltage point and a voltage value this function will set voltage curve point","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga10b82fe6694e893829b879779648ad17","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"num_regions","direction":"inout","parameterdescription":"As input, this is the number of rsmi_freq_volt_region_t structures that can be written to buffer. As output, this is the number of rsmi_freq_volt_region_t structures that were actually written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"rsmi_freq_volt_region_t *","declname":"buffer","direction":"inout","parameterdescription":"a caller provided buffer to which rsmi_freq_volt_region_t structures will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_curve_regions_get","argsstring":"(uint32_t dv_ind, uint32_t *num_regions, rsmi_freq_volt_region_t *buffer)","name":"rsmi_dev_od_volt_curve_regions_get","briefdescription":"This function will retrieve the current valid regions in the frequency\/voltage space.","detaileddescription":"Given a device index , a pointer to an unsigned integer and a buffer of structures, , this function will populate with the current frequency-volt space regions. The caller should assign to memory that can be written to by this function. The caller should also indicate the number of structures that can safely be written to in .The number of regions to expect this function provide () can be obtained by calling .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga2ce7fc9c727c1a1072aab6fe91619e2e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"rsmi_power_profile_status_t *","declname":"status","direction":"inout","parameterdescription":"a pointer to rsmi_power_profile_status_t that will be populated by a call to this function If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_profile_presets_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, rsmi_power_profile_status_t *status)","name":"rsmi_dev_power_profile_presets_get","briefdescription":"Get the list of available preset power profiles and an indication of which profile is currently active.","detaileddescription":"Given a device index and a pointer to a , this function will set the bits of the bit field of to 1 if the profile corresponding to the respective profiles are enabled. For example, if both the VIDEO and VR power profiles are available selections, then AND'ed with will be non-zero as will AND'ed with . Additionally, will be set to the of the profile that is currently active.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfCont_1ga863fc15427807c89b6500e4d90b74024","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t","declname":"perf_lvl","direction":"in","parameterdescription":"the value to which the performance level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_set","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t perf_lvl)","name":"rsmi_dev_perf_level_set","briefdescription":"Set the PowerPlay performance level associated with the device with provided device index with the provided value.","detaileddescription":"Given a device index and an , this function will set the PowerPlay performance level for the device to the value .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1gaf135f00132c8507edd436469af6f480d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t","declname":"perf_lvl","direction":"in","parameterdescription":"the value to which the performance level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_set_v1","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t perf_lvl)","name":"rsmi_dev_perf_level_set_v1","briefdescription":"Set the PowerPlay performance level associated with the device with provided device index with the provided value.","detaileddescription":"Given a device index and an , this function will set the PowerPlay performance level for the device to the value .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1ga8f2adeb0167b9703f9c48ca5f83096a3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"od","direction":"in","parameterdescription":"the value to which the overdrive level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_set","argsstring":"(uint32_t dv_ind, uint32_t od)","name":"rsmi_dev_overdrive_level_set","briefdescription":"Set the overdrive percent associated with the device with provided device index with the provided value. See details for WARNING.","detaileddescription":"Given a device index and an overdrive level , this function will set the overdrive level for the device to the value . The overdrive level is an integer value between 0 and 20, inclusive, which represents the overdrive percentage; e.g., a value of 5 specifies an overclocking of 5%.The overdrive level is specific to the gpu system clock.The overdrive level is the percentage above the maximum Performance Level to which overclocking will be limited. The overclocking percentage does not apply to clock speeds other than the maximum. This percentage is limited to 20%.******WARNING****** Operating your AMD GPU outside of official AMD specifications or outside of factory settings, including but not limited to the conducting of overclocking (including use of this overclocking software, even if such software has been directly or indirectly provided by AMD or otherwise affiliated in any way with AMD), may cause damage to your AMD GPU, system components and\/or result in system failure, as well as cause other problems. DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S WARRANTY. Please use this utility with caution.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1ga006cd2d878b0505b3a173a640d2b253e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"od","direction":"in","parameterdescription":"the value to which the overdrive level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_set_v1","argsstring":"(uint32_t dv_ind, uint32_t od)","name":"rsmi_dev_overdrive_level_set_v1","briefdescription":"Set the overdrive percent associated with the device with provided device index with the provided value. See details for WARNING.","detaileddescription":"Given a device index and an overdrive level , this function will set the overdrive level for the device to the value . The overdrive level is an integer value between 0 and 20, inclusive, which represents the overdrive percentage; e.g., a value of 5 specifies an overclocking of 5%.The overdrive level is specific to the gpu system clock.The overdrive level is the percentage above the maximum Performance Level to which overclocking will be limited. The overclocking percentage does not apply to clock speeds other than the maximum. This percentage is limited to 20%.******WARNING****** Operating your AMD GPU outside of official AMD specifications or outside of factory settings, including but not limited to the conducting of overclocking (including use of this overclocking software, even if such software has been directly or indirectly provided by AMD or otherwise affiliated in any way with AMD), may cause damage to your AMD GPU, system components and\/or result in system failure, as well as cause other problems. DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S WARRANTY. Please use this utility with caution.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1gaad921c61f3227eb2c1f8ef33e2a8870b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_clk_type_t","declname":"clk_type","direction":"in","parameterdescription":"the type of clock for which the set of frequencies will be modified"},{"type":"uint64_t","declname":"freq_bitmask","direction":"in","parameterdescription":"A bitmask indicating the indices of the frequencies that are to be enabled (1) and disabled (0). Only the lowest rsmi_frequencies_t.num_supported bits of this mask are relevant."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_clk_freq_set","argsstring":"(uint32_t dv_ind, rsmi_clk_type_t clk_type, uint64_t freq_bitmask)","name":"rsmi_dev_gpu_clk_freq_set","briefdescription":"Control the set of allowed frequencies that can be used for the specified clock.","detaileddescription":"Given a device index , a clock type , and a 64 bit bitmask , this function will limit the set of allowable frequencies. If a bit in has a value of 1, then the frequency (as ordered in an returned by ) corresponding to that bit index will be allowed.This function will change the performance level to in order to modify the set of allowable frequencies. Caller will need to set to in order to get back to default state.All bits with indices greater than or equal to will be ignored.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__VersQuer_1ga00d80783476c747e29f90aa7477b0a53","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_version_t *","declname":"version","direction":"inout","parameterdescription":"A pointer to an rsmi_version_t structure that will be updated with the version information upon return."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_version_get","argsstring":"(rsmi_version_t *version)","name":"rsmi_version_get","briefdescription":"Get the build version information for the currently running build of RSMI.","detaileddescription":"Get the major, minor, patch and build string for RSMI build currently in use through","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__VersQuer_1ga6d4f034afcef2e50b4e8392c5dfd7a57","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_sw_component_t","declname":"component","direction":"in","parameterdescription":"The component for which the version string is being requested"},{"type":"char *","declname":"ver_str","direction":"inout","parameterdescription":"A pointer to a buffer of char's to which the version of component will be written"},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_version_str_get","argsstring":"(rsmi_sw_component_t component, char *ver_str, uint32_t len)","name":"rsmi_version_str_get","briefdescription":"Get the driver version string for the current system.","detaileddescription":"Given a software component , a pointer to a char buffer, , this function will write the driver version string (up to characters) for the current system to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__VersQuer_1ga2cad3e5c759f7e1f19b157e9d099ed4a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"vbios","direction":"inout","parameterdescription":"A pointer to a buffer of char's to which the VBIOS name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"The number of char's pointed to by vbios which can safely be written to by this function."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vbios_version_get","argsstring":"(uint32_t dv_ind, char *vbios, uint32_t len)","name":"rsmi_dev_vbios_version_get","briefdescription":"Get the VBIOS identifer string.","detaileddescription":"Given a device ID , and a pointer to a char buffer, , this function will write the VBIOS string (up to characters) for device to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__VersQuer_1ga4a855a5c28e632b4e7c13a5640095620","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_fw_block_t","declname":"block","direction":"in","parameterdescription":"The firmware block for which the version is being requested"},{"type":"uint64_t *","declname":"fw_version","direction":"inout","parameterdescription":"The version for the firmware block If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_firmware_version_get","argsstring":"(uint32_t dv_ind, rsmi_fw_block_t block, uint64_t *fw_version)","name":"rsmi_dev_firmware_version_get","briefdescription":"Get the firmware versions for a device.","detaileddescription":"Given a device ID , and a pointer to a uint64_t, , this function will write the FW Versions as a string (up to characters) for device to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1ga91ec4eccaaeedf1b44e7d7fd8e4aa18e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_block_t","declname":"block","direction":"in","parameterdescription":"The block for which error counts should be retrieved"},{"type":"rsmi_error_count_t *","declname":"ec","direction":"inout","parameterdescription":"A pointer to an rsmi_error_count_t to which the error counts should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_count_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_error_count_t *ec)","name":"rsmi_dev_ecc_count_get","briefdescription":"Retrieve the error counts for a GPU block.","detaileddescription":"Given a device index , an and a pointer to an , this function will write the error count values for the GPU block indicated by to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1ga65da2dbb424d29175e9321846d6413bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"enabled_blocks","direction":"inout","parameterdescription":"A pointer to a uint64_t to which the enabled blocks bits will be written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_enabled_get","argsstring":"(uint32_t dv_ind, uint64_t *enabled_blocks)","name":"rsmi_dev_ecc_enabled_get","briefdescription":"Retrieve the enabled ECC bit-mask.","detaileddescription":"Given a device index , and a pointer to a uint64_t , this function will write bits to memory pointed to by . Upon a successful call, can then be AND'd with elements of the ennumeration to determine if the corresponding block has ECC enabled. Note that whether a block has ECC enabled or not in the device is independent of whether there is kernel support for error counting for that block. Although a block may be enabled, but there may not be kernel support for reading error counters for that block.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1ga564d3ff08a256cbde3948809e38b8299","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_block_t","declname":"block","direction":"in","parameterdescription":"The block for which error counts should be retrieved"},{"type":"rsmi_ras_err_state_t *","declname":"state","direction":"inout","parameterdescription":"A pointer to an rsmi_ras_err_state_t to which the ECC state should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_status_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_ras_err_state_t *state)","name":"rsmi_dev_ecc_status_get","briefdescription":"Retrieve the ECC status for a GPU block.","detaileddescription":"Given a device index , an and a pointer to an , this function will write the current state for the GPU block indicated by to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1gaaf37a3e9252f0d37eac6d7b91a9c6ead","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_status_t","declname":"status","direction":"in","parameterdescription":"The error status for which a description is desired"},{"type":"const char **","declname":"status_string","direction":"inout","parameterdescription":"A pointer to a const char * which will be made to point to a description of the provided error code"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_status_string","argsstring":"(rsmi_status_t status, const char **status_string)","name":"rsmi_status_string","briefdescription":"Get a description of a provided RSMI error status.","detaileddescription":"Set the provided pointer to a const char *, , to a string containing a description of the provided error code .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__PerfCntr_1gacc8df7e5918c52a5aa42379756b70d11","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"device index of device being queried"},{"type":"rsmi_event_group_t","declname":"group","direction":"in","parameterdescription":"rsmi_event_group_t identifier of group for which support is being queried"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_group_supported","argsstring":"(uint32_t dv_ind, rsmi_event_group_t group)","name":"rsmi_dev_counter_group_supported","briefdescription":"Tell if an event group is supported by a given device.","detaileddescription":"Given a device index and an event group specifier , tell if type events are supported by the device associated with","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSif the device associatee with dv_ind support counting events of the type indicated by group. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments group"},{"kind":"function","id":"group__PerfCntr_1gaab82a28e74979ae7b0313096f47bec6e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_event_type_t","declname":"type","direction":"in","parameterdescription":"the rsmi_event_type_t of performance event to create"},{"type":"rsmi_event_handle_t *","declname":"evnt_handle","direction":"inout","parameterdescription":"A pointer to a rsmi_event_handle_t which will be associated with a newly allocated counter If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_create","argsstring":"(uint32_t dv_ind, rsmi_event_type_t type, rsmi_event_handle_t *evnt_handle)","name":"rsmi_dev_counter_create","briefdescription":"Create a performance counter object.","detaileddescription":"Create a performance counter object of type for the device with a device index of , and write a handle to the object to the memory location pointed to by . can be used with other performance event operations. The handle should be deallocated with when no longer needed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_OUT_OF_RESOURCESunable to allocate memory for counter RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga91e6477909591dc3558e3dcdb2e8d060","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evnt_handle","direction":"in","parameterdescription":"handle to event object to be deallocated"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_destroy","argsstring":"(rsmi_event_handle_t evnt_handle)","name":"rsmi_dev_counter_destroy","briefdescription":"Deallocate a performance counter object.","detaileddescription":"Deallocate the performance counter object with the provided","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga662c37dfc32d75082834dc566fa72205","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evt_handle","direction":"in","parameterdescription":"an event handle"},{"type":"rsmi_counter_command_t","declname":"cmd","direction":"in","parameterdescription":"The event counter command to be issued"},{"type":"void *","declname":"cmd_args","direction":"inout","parameterdescription":"Currently not used. Should be set to NULL."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_control","argsstring":"(rsmi_event_handle_t evt_handle, rsmi_counter_command_t cmd, void *cmd_args)","name":"rsmi_counter_control","briefdescription":"Issue performance counter control commands.","detaileddescription":"Issue a command on the event counter associated with the provided handle .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga7299b0180746ddaa44b3653ad8cc2474","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evt_handle","direction":"in","parameterdescription":"an event handle"},{"type":"rsmi_counter_value_t *","declname":"value","direction":"inout","parameterdescription":"pointer to memory of size of rsmi_counter_value_t to which the counter value will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_read","argsstring":"(rsmi_event_handle_t evt_handle, rsmi_counter_value_t *value)","name":"rsmi_counter_read","briefdescription":"Read the current value of a performance counter.","detaileddescription":"Read the current counter value of the counter associated with the provided handle and write the value to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga8f410092c82feb4cf339d85adf717f01","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_event_group_t","declname":"grp","direction":"in","parameterdescription":"an event device group"},{"type":"uint32_t *","declname":"available","direction":"inout","parameterdescription":"A pointer to a uint32_t to which the number of available counters will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_available_counters_get","argsstring":"(uint32_t dv_ind, rsmi_event_group_t grp, uint32_t *available)","name":"rsmi_counter_available_counters_get","briefdescription":"Get the number of currently available counters.","detaileddescription":"Given a device index , a performance event group , and a pointer to a uint32_t , this function will write the number of type counters that are available on the device with index to the memory that points to.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__SysInfo_1gafa7c4ee760160af2f13238a63f053a4c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_process_info_t *","declname":"procs","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which process information will be written. This may be NULL in which case only num_items will be updated with the number of processes found."},{"type":"uint32_t *","declname":"num_items","direction":"inout","parameterdescription":"A pointer to a uint32_t, which on input, should contain the amount of memory in rsmi_process_info_t's which have been provided by the procs argument. On output, if procs is non-NULL, this will be updated with the number rsmi_process_info_t structs actually written. If procs is NULL, this argument will be updated with the number processes for which there is information."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_get","argsstring":"(rsmi_process_info_t *procs, uint32_t *num_items)","name":"rsmi_compute_process_info_get","briefdescription":"Get process information about processes currently using GPU.","detaileddescription":"Given a non-NULL pointer to an array of 's, of length *, this function will write up to * instances of to the memory pointed to by . These instances contain information about each process utilizing a GPU. If is not NULL, will be updated with the number of processes actually written. If is NULL, will be updated with the number of processes for which there is current process information. Calling this function with being NULL is a way to determine how much memory should be allocated for when is not NULL.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if there were more processes for which information was available, but not enough space was provided as indicated by procs and num_items, on input."},{"kind":"function","id":"group__SysInfo_1gaf5c740b1fa460ddc8f2df6c18555120b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process ID for which process information is being requested"},{"type":"rsmi_process_info_t *","declname":"proc","direction":"inout","parameterdescription":"a pointer to a rsmi_process_info_t to which process information for pid will be written if it is found."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_by_pid_get","argsstring":"(uint32_t pid, rsmi_process_info_t *proc)","name":"rsmi_compute_process_info_by_pid_get","briefdescription":"Get process information about a specific process.","detaileddescription":"Given a pointer to an and a process id , this function will write the process information for , if available, to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_NOT_FOUNDis returned if there was no process information found for the provided pid"},{"kind":"function","id":"group__SysInfo_1ga819f64fd24a2c52202cac421c9156428","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process id of the process for which the number of gpus currently being used is requested"},{"type":"uint32_t *","declname":"dv_indices","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which indices of devices currently being used by the process will be written. This may be NULL in which case only num_devices will be updated with the number of devices being used."},{"type":"uint32_t *","declname":"num_devices","direction":"inout","parameterdescription":"A pointer to a uint32_t, which on input, should contain the amount of memory in uint32_t's which have been provided by the dv_indices argument. On output, if dv_indices is non-NULL, this will be updated with the number uint32_t's actually written. If dv_indices is NULL, this argument will be updated with the number devices being used."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_gpus_get","argsstring":"(uint32_t pid, uint32_t *dv_indices, uint32_t *num_devices)","name":"rsmi_compute_process_gpus_get","briefdescription":"Get the device indices currently being used by a process.","detaileddescription":"Given a process id , a non-NULL pointer to an array of uint32_t's of length *, this function will write up to device indices to the memory pointed to by . If is not NULL, will be updated with the number of gpu's currently being used by process . If is NULL, will be updated with the number of gpus currently being used by . Calling this function with being NULL is a way to determine how much memory is required for when is not NULL.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if there were more gpu indices that could have been written, but not enough space was provided as indicated by dv_indices and num_devices, on input."},{"kind":"function","id":"group__SysInfo_1ga380fba5bb8f7d8825981e7071670934f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process id of the process for which the gpu currently being used is requested."},{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index where the process running on."},{"type":"rsmi_process_info_t *","declname":"proc","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which process information will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_by_device_get","argsstring":"(uint32_t pid, uint32_t dv_ind, rsmi_process_info_t *proc)","name":"rsmi_compute_process_info_by_device_get","briefdescription":"Get the info of a process on a specific device.","detaileddescription":"Given a process id , a , this function will write the process information for pid on the device, if available, to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__XGMIInfo_1ga7d4c0f238ef2658db363b53967933abd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_xgmi_status_t *","declname":"status","direction":"inout","parameterdescription":"A pointer to an rsmi_xgmi_status_t to which the XGMI error state should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_error_status","argsstring":"(uint32_t dv_ind, rsmi_xgmi_status_t *status)","name":"rsmi_dev_xgmi_error_status","briefdescription":"Retrieve the XGMI error status for a device.","detaileddescription":"Given a device index , and a pointer to an , this function will write the current XGMI error state for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__XGMIInfo_1gac3cf583cddbac54bed8f39b05539567b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_error_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_xgmi_error_reset","briefdescription":"Reset the XGMI error status for a device.","detaileddescription":"Given a device index , this function will reset the current XGMI error state for the device to rsmi_xgmi_status_t::RSMI_XGMI_STATUS_NO_ERRORS","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__XGMIInfo_1gaddca720006d546aaa3500aff76337770","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"hive_id","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the XGMI hive id should be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_hive_id_get","argsstring":"(uint32_t dv_ind, uint64_t *hive_id)","name":"rsmi_dev_xgmi_hive_id_get","briefdescription":"Retrieve the XGMI hive id for a device.","detaileddescription":"Given a device index , and a pointer to an uint64_t , this function will write the current XGMI hive id for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga99bdcce451e3c64123b9cde07f56d23c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"numa_node","direction":"inout","parameterdescription":"A pointer to an uint32_t to which the numa node number should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_numa_node_number","argsstring":"(uint32_t dv_ind, uint32_t *numa_node)","name":"rsmi_topo_get_numa_node_number","briefdescription":"Retrieve the NUMA CPU node number for a device.","detaileddescription":"Given a device index , and a pointer to an uint32_t , this function will write the node number of NUMA CPU for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga5bca00f4277b9236705180cc4f2a1374","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"weight","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the weight for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_link_weight","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *weight)","name":"rsmi_topo_get_link_weight","briefdescription":"Retrieve the weight for a connection between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , and a pointer to an uint64_t , this function will write the weight for the connection between the device and to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga7932d8de034046e2674849d85c09c899","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"min_bandwidth","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the minimal bandwidth for the connection should be written."},{"type":"uint64_t *","declname":"max_bandwidth","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the maximal bandwidth for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_minmax_bandwidth_get","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *min_bandwidth, uint64_t *max_bandwidth)","name":"rsmi_minmax_bandwidth_get","briefdescription":"Retreive minimal and maximal io link bandwidth between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , pointer to an uint64_t , and a pointer to uint64_t , this function will write theoretical minimal and maximal bandwidth limits. API works if src and dst are connected via xgmi and have 1 hop distance.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga27229edf8cd2a7cdcd2d2612152e8db1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"hops","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the hops for the connection should be written."},{"type":"RSMI_IO_LINK_TYPE *","declname":"type","direction":"inout","parameterdescription":"A pointer to an RSMI_IO_LINK_TYPE to which the type for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_link_type","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *hops, RSMI_IO_LINK_TYPE *type)","name":"rsmi_topo_get_link_type","briefdescription":"Retrieve the hops and the connection type between GPU to GPU\/CPU.","detaileddescription":"Given a source device index and a destination device index , and a pointer to an uint64_t and a pointer to an RSMI_IO_LINK_TYPE , this function will write the number of hops and the connection type between the device and to the memory pointed to by and .To query the link type between GPU and CPU, given a source GPU index and a destination device index , a pointer to an uint64_t and a pointer to an RSMI_IO_LINK_TYPE , this function will write the number of hops and the connection type between the device and CPU to the memory pointed to by and .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga91767a23b1025c571f44e53120857421","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"bool *","declname":"accessible","direction":"inout","parameterdescription":"A pointer to a bool to which the status for the P2P connection availablity should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_is_P2P_accessible","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, bool *accessible)","name":"rsmi_is_P2P_accessible","briefdescription":"Return P2P availability status between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , and a pointer to a bool , this function will write the P2P connection status between the device and to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ComputePartition_1gaf7bdbc0a7068bc74c32129a3baca2e8b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"compute_partition","direction":"inout","parameterdescription":"a pointer to a char string variable, which the device's current compute partition will be written to."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer compute_partition , suggested length is 4 or greater."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_get","argsstring":"(uint32_t dv_ind, char *compute_partition, uint32_t len)","name":"rsmi_dev_compute_partition_get","briefdescription":"Retrieves the current compute partitioning for a desired device.","detaileddescription":"Given a device index and a string , and uint32 , this function will attempt to obtain the device's current compute partition setting string. Upon successful retreival, the obtained device's compute partition settings string shall be stored in the passed char string variable.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATAdata provided to function is not valid RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire compute partition value. In this case, only len bytes will be written."},{"kind":"function","id":"group__ComputePartition_1ga850de48a73477ccc471097dc172ff1e4","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_compute_partition_type_t","declname":"compute_partition","direction":"in","parameterdescription":"using enum rsmi_compute_partition_type_t, define what the selected device's compute partition setting should be updated to."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_set","argsstring":"(uint32_t dv_ind, rsmi_compute_partition_type_t compute_partition)","name":"rsmi_dev_compute_partition_set","briefdescription":"Modifies a selected device's compute partition setting.","detaileddescription":"Given a device index , a type of compute partition , this function will attempt to update the selected device's compute partition setting.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_SETTING_UNAVAILABLEthe provided setting is unavailable for current device RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__ComputePartition_1ga05438b725fef9f413bb6f1ca084ffe6e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_compute_partition_reset","briefdescription":"Reverts a selected device's compute partition setting back to its boot state.","detaileddescription":"Given a device index , this function will attempt to revert its compute partition setting back to its boot state.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__memory__partition_1ga2dc7c0a12b9fcb1c6fe9ded26524a6cc","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"memory_partition","direction":"inout","parameterdescription":"a pointer to a char string variable, which the device's memory partition will be written to."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer memory_partition , suggested length is 5 or greater."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_get","argsstring":"(uint32_t dv_ind, char *memory_partition, uint32_t len)","name":"rsmi_dev_memory_partition_get","briefdescription":"Retrieves the current memory partition for a desired device.","detaileddescription":"Given a device index and a string , and uint32 , this function will attempt to obtain the device's memory partition string. Upon successful retreival, the obtained device's memory partition string shall be stored in the passed char string variable.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATAdata provided to function is not valid RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire memory partition value. In this case, only len bytes will be written."},{"kind":"function","id":"group__memory__partition_1ga3e17898ccc0410df1646d35e5bf944b7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_partition_type_t","declname":"memory_partition","direction":"in","parameterdescription":"using enum rsmi_memory_partition_type_t, define what the selected device's current mode setting should be updated to."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_set","argsstring":"(uint32_t dv_ind, rsmi_memory_partition_type_t memory_partition)","name":"rsmi_dev_memory_partition_set","briefdescription":"Modifies a selected device's current memory partition setting.","detaileddescription":"Given a device index and a type of memory partition , this function will attempt to update the selected device's memory partition setting.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_AMDGPU_RESTART_ERRcould not successfully restart the amdgpu driver RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__memory__partition_1gad5712733c307d7297f8ab7dc01973563","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_memory_partition_reset","briefdescription":"Reverts a selected device's memory partition setting back to its boot state.","detaileddescription":"Given a device index , this function will attempt to revert its current memory partition setting back to its boot state.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_AMDGPU_RESTART_ERRcould not successfully restart the amdgpu driver RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__APISupport_1ga8c14593e6886a1f63bc52d3a380fa50d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index of device for which support information is requested"},{"type":"rsmi_func_id_iter_handle_t *","declname":"handle","direction":"inout","parameterdescription":"A pointer to caller-provided memory to which the function iterator will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_func_iterator_open","argsstring":"(uint32_t dv_ind, rsmi_func_id_iter_handle_t *handle)","name":"rsmi_dev_supported_func_iterator_open","briefdescription":"Get a function name iterator of supported RSMI functions for a device.","detaileddescription":"Given a device index , this function will write a function iterator handle to the caller-provided memory pointed to by . This handle can be used to iterate through all the supported functions.Note that although this function takes in as an argument, itself will not be among the functions listed as supported. This is because does not depend on hardware or driver support and should always be supported.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga33c94fd59e341d5e879dcbe4efed9a2b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"obj_h","direction":"in","parameterdescription":"an iterator handle for which the variants are being requested"},{"type":"rsmi_func_id_iter_handle_t *","declname":"var_iter","direction":"inout","parameterdescription":"A pointer to caller-provided memory to which the sub-variant iterator will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_variant_iterator_open","argsstring":"(rsmi_func_id_iter_handle_t obj_h, rsmi_func_id_iter_handle_t *var_iter)","name":"rsmi_dev_supported_variant_iterator_open","briefdescription":"Get a variant iterator for a given handle.","detaileddescription":"Given a , this function will write a function iterator handle to the caller-provided memory pointed to by . This handle can be used to iterate through all the supported variants of the provided handle. may be a handle to a function object, as provided by a call to , or it may be a variant itself (from a call to ), it which case will be an iterator of the sub-variants of (e.g., monitors).This call allocates a small amount of memory to . To free this memory should be called on the returned iterator handle when it is no longer needed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga359b1a5ed84d1454a16541e77523dc9d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"handle","direction":"in","parameterdescription":"A pointer to an iterator handle to be incremented"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_func_iter_next","argsstring":"(rsmi_func_id_iter_handle_t handle)","name":"rsmi_func_iter_next","briefdescription":"Advance a function identifer iterator.","detaileddescription":"Given a function id iterator handle () , this function will increment the iterator to point to the next identifier. After a successful call to this function, obtaining the value of the iterator will provide the value of the next item in the list of functions\/variants.If there are no more items in the list, is returned.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NO_DATAis returned when list of identifiers has been exhausted"},{"kind":"function","id":"group__APISupport_1ga3e8d85fe092fc654014f1cc5e26e0268","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t *","declname":"handle","direction":"in","parameterdescription":"A pointer to an iterator handle to be closed"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_func_iterator_close","argsstring":"(rsmi_func_id_iter_handle_t *handle)","name":"rsmi_dev_supported_func_iterator_close","briefdescription":"Close a variant iterator handle.","detaileddescription":"Given a pointer to an , this function will free the resources being used by the handle","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga0e70dbb9825f517e562bd6a782d05650","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"handle","direction":"in","parameterdescription":"An iterator for which the value is being requested"},{"type":"rsmi_func_id_value_t *","declname":"value","direction":"inout","parameterdescription":"A pointer to an rsmi_func_id_value_t provided by the caller to which this function will write the value assocaited with handle"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_func_iter_value_get","argsstring":"(rsmi_func_id_iter_handle_t handle, rsmi_func_id_value_t *value)","name":"rsmi_func_iter_value_get","briefdescription":"Get the value associated with a function\/variant iterator.","detaileddescription":"Given an , this function will write the identifier of the function\/variant to the user provided memory pointed to by . may point to a function name, a variant id, or a monitor\/sensor index, depending on what kind of iterator is","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__EvntNotif_1gaba7582ffae49eaa4edebcb3a5b5c7d2a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":null,"parameterdescription":"a device index corresponding to the device on which to listen for events"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_init","argsstring":"(uint32_t dv_ind)","name":"rsmi_event_notification_init","briefdescription":"Prepare to collect event notifications for a GPU.","detaileddescription":"This function prepares to collect events for the GPU with device ID , by initializing any required system parameters. This call may open files which will remain open until is called.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__EvntNotif_1gae95cc3c3857bf4d3568789b894f1a494","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":null,"parameterdescription":"a device index corresponding to the device on which to listen for events"},{"type":"uint64_t","declname":"mask","direction":null,"parameterdescription":"Bitmask generated by OR'ing 1 or more elements of rsmi_evt_notification_type_t indicating which event types to listen for, where the rsmi_evt_notification_type_t value indicates the bit field, with bit position starting from 1. For example, if the mask field is 0x0000000000000003, which means first bit, bit 1 (bit position start from 1) and bit 2 are set, which indicate interest in receiving RSMI_EVT_NOTIF_VMFAULT (which has a value of 1) and RSMI_EVT_NOTIF_THERMAL_THROTTLE event (which has a value of 2)."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_mask_set","argsstring":"(uint32_t dv_ind, uint64_t mask)","name":"rsmi_event_notification_mask_set","briefdescription":"Specify which events to collect for a device.","detaileddescription":"Given a device index and a consisting of elements of OR'd together, this function will listen for the events specified in on the device corresponding to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_INIT_ERRORis returned if rsmi_event_notification_init() has not been called before a call to this functionRSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__EvntNotif_1ga79aa327ce4f2f09f150401123fcd8bd5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"int","declname":"timeout_ms","direction":"in","parameterdescription":"number of milliseconds to wait for an event to occur"},{"type":"uint32_t *","declname":"num_elem","direction":"inout","parameterdescription":"pointer to uint32_t, provided by the caller. On input, this value tells how many rsmi_evt_notification_data_t elements are being provided by the caller with data. On output, the location pointed to by num_elem will contain the number of items written to the provided buffer."},{"type":"rsmi_evt_notification_data_t *","declname":"data","direction":"out","parameterdescription":"pointer to a caller-provided memory buffer of size num_elem rsmi_evt_notification_data_t to which this function may safely write. If there are events found, up to num_elem event items will be written to data."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_get","argsstring":"(int timeout_ms, uint32_t *num_elem, rsmi_evt_notification_data_t *data)","name":"rsmi_event_notification_get","briefdescription":"Collect event notifications, waiting a specified amount of time.","detaileddescription":"Given a time period in milliseconds and a caller- provided buffer of 's with a length (in 's, also specified by the caller) in the memory location pointed to by , this function will collect events for up to milliseconds, and write up to * event items to . Upon return is updated with the number of events that were actually written. If events are already present when this function is called, it will write the events to the buffer then poll for new events if there is still caller-provided buffer available to write any new events that would be found.This function requires prior calls to and . This function polls for the occurrance of the events on the respective devices that were previously specified by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSThe function ran successfully. The events that were found are written to data and num_elems is updated with the number of elements that were written.RSMI_STATUS_NO_DATANo events were found to collect."},{"kind":"function","id":"group__EvntNotif_1ga4077a7dd78683d0f867616f86a693275","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"The device index of the GPU for which event notification resources will be free"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_stop","argsstring":"(uint32_t dv_ind)","name":"rsmi_event_notification_stop","briefdescription":"Close any file handles and free any resources used by event notification for a GPU.","detaileddescription":"Any resources used by event notification for the GPU with device index will be free with this function. This includes freeing any memory and closing file handles. This should be called for every call to","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_INVALID_ARGSresources for the given device have either already been freed, or were never allocated by rsmi_event_notification_init()RSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__GPU_1ga235db82b8db19ab2b5819e09ebed5dad","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"hotspot_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_hotspot_get","argsstring":"(uint32_t dv_ind, uint16_t *hotspot_value)","name":"rsmi_dev_metrics_temp_hotspot_get","briefdescription":"Get the 'temp_hotspot' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_hotspot' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab6b6e0ab0348ae257575a09c8d020677","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"mem_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_mem_get","argsstring":"(uint32_t dv_ind, uint16_t *mem_value)","name":"rsmi_dev_metrics_temp_mem_get","briefdescription":"Get the 'temp_mem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_mem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab3f0b2e2bd7915b8aafd9a6fb2b0899c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrsoc_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrsoc_get","argsstring":"(uint32_t dv_ind, uint16_t *vrsoc_value)","name":"rsmi_dev_metrics_temp_vrsoc_get","briefdescription":"Get the 'temp_vrsoc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrsoc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga3b20cab9dde467f222bc91798e07fa9c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"socket_power_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_socket_power_get","argsstring":"(uint32_t dv_ind, uint16_t *socket_power_value)","name":"rsmi_dev_metrics_curr_socket_power_get","briefdescription":"Get the 'curr_socket_power' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'socket_power' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga33f1b3e5642d8a06a151363098ea2a45","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"gfx_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_gfx_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *gfx_activity_value)","name":"rsmi_dev_metrics_avg_gfx_activity_get","briefdescription":"Get the 'avg_gfx_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'gfx_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gadb3f5d55a0a2e2230e751f4bd6697f4b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"umc_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_umc_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *umc_activity_value)","name":"rsmi_dev_metrics_avg_umc_activity_get","briefdescription":"Get the 'avg_umc_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'umc_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaedc053805b82ee8971a23f6fa0630933","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"energy_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_energy_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *energy_acc_value)","name":"rsmi_dev_metrics_energy_acc_get","briefdescription":"Get the 'energy_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'energy_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga69fe25fc52880193ce3dc9bf56940160","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"system_clock_counter_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_system_clock_counter_get","argsstring":"(uint32_t dv_ind, uint64_t *system_clock_counter_value)","name":"rsmi_dev_metrics_system_clock_counter_get","briefdescription":"Get the 'system_clock_counter' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'system_clock_counter' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf6ca450a7a4bcbc243184e578c5e40f5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"firmware_timestamp_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_firmware_timestamp_get","argsstring":"(uint32_t dv_ind, uint64_t *firmware_timestamp_value)","name":"rsmi_dev_metrics_firmware_timestamp_get","briefdescription":"Get the 'firmware_timestamp' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'firmware_timestamp' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga61e5ce4e8fddc241658186f35360fd27","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"throttle_status_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_throttle_status_get","argsstring":"(uint32_t dv_ind, uint32_t *throttle_status_value)","name":"rsmi_dev_metrics_throttle_status_get","briefdescription":"Get the 'throttle_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'throttle_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga9d4a7a6f37ac79ca6afcaa380ad83504","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"pcie_link_width_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_link_width_get","argsstring":"(uint32_t dv_ind, uint16_t *pcie_link_width_value)","name":"rsmi_dev_metrics_pcie_link_width_get","briefdescription":"Get the 'pcie_link_width' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'pcie_link_width' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga71d48303828626ae12974659a8bda5ba","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"pcie_link_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_link_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *pcie_link_speed_value)","name":"rsmi_dev_metrics_pcie_link_speed_get","briefdescription":"Get the 'pcie_link_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'pcie_link_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga80fd8b72b3319bda4781f298b308d340","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xgmi_link_width_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_link_width_get","argsstring":"(uint32_t dv_ind, uint16_t *xgmi_link_width_value)","name":"rsmi_dev_metrics_xgmi_link_width_get","briefdescription":"Get the 'xgmi_link_width' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xgmi_link_width' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga5b0e21556be047e07e7f0d61f8210e72","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xgmi_link_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_link_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *xgmi_link_speed_value)","name":"rsmi_dev_metrics_xgmi_link_speed_get","briefdescription":"Get the 'xgmi_link_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xgmi_link_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7dafe8194d9134da38712ac42fc0bc52","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"gfxclk_lock_status_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_gfxclk_lock_status_get","argsstring":"(uint32_t dv_ind, uint32_t *gfxclk_lock_status_value)","name":"rsmi_dev_metrics_gfxclk_lock_status_get","briefdescription":"Get the 'gfxclk_lock_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'gfxclk_lock_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga2f61603bc7bc487d33fef8ba7a405b53","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"gfx_activity_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_gfx_activity_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *gfx_activity_acc_value)","name":"rsmi_dev_metrics_gfx_activity_acc_get","briefdescription":"Get the 'gfx_activity_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'gfx_activity_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga8d3f7a9d3f01fa2b08488c24aafedd98","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"mem_activity_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_mem_activity_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *mem_activity_acc_value)","name":"rsmi_dev_metrics_mem_activity_acc_get","briefdescription":"Get the 'mem_activity_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_activity_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga37263865409b458ca4187b792929e28e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_bandwidth_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_bandwidth_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_bandwidth_acc_value)","name":"rsmi_dev_metrics_pcie_bandwidth_acc_get","briefdescription":"Get the 'pcie_bandwidth_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_bandwidth_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga40a167d188508c28da5508eb93d6cca5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_bandwidth_inst_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_bandwidth_inst_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_bandwidth_inst_value)","name":"rsmi_dev_metrics_pcie_bandwidth_inst_get","briefdescription":"Get the 'pcie_bandwidth_inst' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_bandwidth_inst' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga6cb8357b042d6142af29ef65d2927f19","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_l0_recov_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_l0_recov_count_acc_get","briefdescription":"Get the 'pcie_l0_recov_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_l0_recov_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga23a2ba7ce12d2c31a30f204b2b03e7ef","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_replay_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_replay_count_acc_get","briefdescription":"Get the 'pcie_replay_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_replay_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac79f7f0d22b4728d421f821aaf845fd5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_replay_rover_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_replay_rover_count_acc_get","briefdescription":"Get the 'pcie_replay_rover_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_replay_rover_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac8ac6583d3b7912a82d6958c53402bad","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"pcie_nak_sent_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_nak_sent_count_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *pcie_nak_sent_count_acc_value)","name":"rsmi_dev_metrics_pcie_nak_sent_count_acc_get","briefdescription":"Get the 'pcie_nak_sent_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_max_bandwidth_usage' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gae9ebfed1f934aa10f189f7854d6b35bf","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"pcie_nak_rcvd_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_nak_rcvd_count_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *pcie_nak_rcvd_count_acc_value)","name":"rsmi_dev_metrics_pcie_nak_rcvd_count_acc_get","briefdescription":"Get the 'pcie_nak_rcvd_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_max_bandwidth_usage' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf06cf38ffc1b6d905bbe6a4a4a367056","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"uclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_uclk_get","argsstring":"(uint32_t dv_ind, uint16_t *uclk_value)","name":"rsmi_dev_metrics_curr_uclk_get","briefdescription":"Get the 'curr_uclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_uclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad2f37d6ee2707ffd51ec8126113cf041","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricTempHbm_t *","declname":"temp_hbm_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_NUM_HBM_INSTANCES) element array (GPUMetricTempHbm_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_hbm_get","argsstring":"(uint32_t dv_ind, GPUMetricTempHbm_t *temp_hbm_value)","name":"rsmi_dev_metrics_temp_hbm_get","briefdescription":"Get the 'temp_hbm' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_hbm' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga79b2808b7731f2428201a19066b44844","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricVcnActivity_t *","declname":"vcn_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_VCNS) element array (GPUMetricVcnActivity_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_vcn_activity_get","argsstring":"(uint32_t dv_ind, GPUMetricVcnActivity_t *vcn_activity_value)","name":"rsmi_dev_metrics_vcn_activity_get","briefdescription":"Get the 'vcn_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'vcn_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaff6aeb8024d61b53d2c863f0d43ca580","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricJpegActivity_t *","declname":"jpeg_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 32 (RSMI_MAX_NUM_JPEG_ENGS) element array (GPUMetricJpegActivity_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_jpeg_activity_get","argsstring":"(uint32_t dv_ind, GPUMetricJpegActivity_t *jpeg_activity_value)","name":"rsmi_dev_metrics_jpeg_activity_get","briefdescription":"Get the 'jpeg_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'vcn_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaac99d0b534ca00efbde025caa127d3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricXgmiReadDataAcc_t *","declname":"xgmi_read_data_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS) element array (GPUMetricXgmiReadDataAcc_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_read_data_get","argsstring":"(uint32_t dv_ind, GPUMetricXgmiReadDataAcc_t *xgmi_read_data_acc_value)","name":"rsmi_dev_metrics_xgmi_read_data_get","briefdescription":"Get the 'xgmi_read_data' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'xgmi_read_data' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafdeaca7b5d52cb3008f43c65b3244c1c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricXgmiWriteDataAcc_t *","declname":"xgmi_write_data_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS) element array (GPUMetricXgmiWriteDataAcc_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_write_data_get","argsstring":"(uint32_t dv_ind, GPUMetricXgmiWriteDataAcc_t *xgmi_write_data_acc_value)","name":"rsmi_dev_metrics_xgmi_write_data_get","briefdescription":"Get the 'xgmi_write_data' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'xgmi_write_data' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaedc8543c8dba375e457d05b3e4bc465","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrGfxClk_t *","declname":"current_gfxclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_GFX_CLKS) element array (GPUMetricCurrGfxClk_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_gfxclk_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrGfxClk_t *current_gfxclk_value)","name":"rsmi_dev_metrics_curr_gfxclk_get","briefdescription":"Get the 'curr_gfxclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'curr_gfxclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga4ace8508318e17343ee2c569e0dcb34a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrSocClk_t *","declname":"current_socclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrSocClk_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_socclk_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrSocClk_t *current_socclk_value)","name":"rsmi_dev_metrics_curr_socclk_get","briefdescription":"Get the 'curr_socclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_socclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafd61e106e116973d02701e822d3b7ab0","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrVClk0_t *","declname":"current_vclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrVClk0_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_vclk0_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrVClk0_t *current_vclk_value)","name":"rsmi_dev_metrics_curr_vclk0_get","briefdescription":"Get the 'curr_vclk0' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_vclk0' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad3cfab59d89131605ff519835fa4265b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrDClk0_t *","declname":"current_dclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrDClk0_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_dclk0_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrDClk0_t *current_dclk_value)","name":"rsmi_dev_metrics_curr_dclk0_get","briefdescription":"Get the 'curr_dclk0' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_dclk0' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7df1376ff4805664035f32201280d3e1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"edge_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_edge_get","argsstring":"(uint32_t dv_ind, uint16_t *edge_value)","name":"rsmi_dev_metrics_temp_edge_get","briefdescription":"Get the 'temp_edge' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_edge' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaed3ca62f4b7a42554d34ea3fb77dafd3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrgfx_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrgfx_get","argsstring":"(uint32_t dv_ind, uint16_t *vrgfx_value)","name":"rsmi_dev_metrics_temp_vrgfx_get","briefdescription":"Get the 'temp_vrgfx' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrgfx' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga4536d67af9aad85e8583f010e73a91e9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrmem_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrmem_get","argsstring":"(uint32_t dv_ind, uint16_t *vrmem_value)","name":"rsmi_dev_metrics_temp_vrmem_get","briefdescription":"Get the 'temp_vrmem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrmem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga8e8196a531893531b093c5f80ecad50a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"mm_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_mm_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *mm_activity_value)","name":"rsmi_dev_metrics_avg_mm_activity_get","briefdescription":"Get the 'avg_mm_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_mm_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga65a60575b31d68fca05f7ad300f7d412","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"current_vclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_vclk1_get","argsstring":"(uint32_t dv_ind, uint16_t *current_vclk_value)","name":"rsmi_dev_metrics_curr_vclk1_get","briefdescription":"Get the 'curr_vclk1' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_vclk1' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga71cbf01f5e18fb1342c8e087a807ab3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"current_dclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_dclk1_get","argsstring":"(uint32_t dv_ind, uint16_t *current_dclk_value)","name":"rsmi_dev_metrics_curr_dclk1_get","briefdescription":"Get the 'curr_dclk1' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_dclk1' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac7f63ce12d98d75189ba86062eb9218c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"throttle_status_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_indep_throttle_status_get","argsstring":"(uint32_t dv_ind, uint64_t *throttle_status_value)","name":"rsmi_dev_metrics_indep_throttle_status_get","briefdescription":"Get the 'indep_throttle_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'indep_throttle_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad8dcf15777380183e3a812327dcfed95","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"socket_power_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_socket_power_get","argsstring":"(uint32_t dv_ind, uint16_t *socket_power_value)","name":"rsmi_dev_metrics_avg_socket_power_get","briefdescription":"Get the 'avg_socket_power' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_socket_power' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga02d935a7a7358c57ccfbb0a49f847689","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"fan_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_fan_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *fan_speed_value)","name":"rsmi_dev_metrics_curr_fan_speed_get","briefdescription":"Get the 'curr_fan_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_fan_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga862cc040b0b61cd3a0a71d9ba3dac30b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_gfx_clock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_gfx_clock_frequency_get","briefdescription":"Get the 'avg_gfx_clock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_gfx_clock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga3ecc6556963b583beb18426839a5f582","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_soc_clock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_soc_clock_frequency_get","briefdescription":"Get the 'avg_soc_clock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_soc_clock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaeee03ae25ae1d82d24b4996d145be038","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_uclock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_uclock_frequency_get","briefdescription":"Get the 'avg_uclock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_uclock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gae6384d1c91fea3c4a96f649d94292350","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_vclock0_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_vclock0_frequency_get","briefdescription":"Get the 'avg_vclock0_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_vclock0_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaacd2d36aae3a2260f0adcc34e9c85f3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_dclock0_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_dclock0_frequency_get","briefdescription":"Get the 'avg_dclock0_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_dclock0_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf477b11657735e28369cb821938db651","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_vclock1_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_vclock1_frequency_get","briefdescription":"Get the 'avg_vclock1_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_vclock1_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga0a810f5446d35b0385f74b6cda422c3c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_dclock1_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_dclock1_frequency_get","briefdescription":"Get the 'avg_dclock1_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_dclock1_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7d3439b56c71d14c3d1985e7389e47a9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_soc_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_soc_get","briefdescription":"Get the 'volt_soc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_soc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga1c50b39c3ae7bd1020ba4bca53205a10","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_gfx_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_gfx_get","briefdescription":"Get the 'volt_gfx' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_gfx' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga1c1a5c21c3d861cc83f1fad10933de69","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_mem_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_mem_get","briefdescription":"Get the 'volt_mem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_mem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab730a6f75081e955266412c94051014f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"metrics_table_header_t *","declname":"header_value","direction":"inout","parameterdescription":"a pointer to metrics_table_header_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_header_info_get","argsstring":"(uint32_t dv_ind, metrics_table_header_t *header_value)","name":"rsmi_dev_metrics_header_info_get","briefdescription":"Get the 'metrics_header_info' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a in which the 'metrics_header_info' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaf2a1a098ed05868571387b73e24916f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xcd_counter_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xcd_counter_get","argsstring":"(uint32_t dv_ind, uint16_t *xcd_counter_value)","name":"rsmi_dev_metrics_xcd_counter_get","briefdescription":"Get the 'xcd_counter' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xcd_counter' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafaf5ad7c0189346056ec8a5e5219d0cc","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_log_get","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_metrics_log_get","briefdescription":"Get the log from the GPU metrics associated with the device.","detaileddescription":"Given a device index it will log all the gpu metric info related to the device. The 'logging' feature must be on.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."}]}
{"id":"group__InitShutAdmin","kind":"group","language":null,"prot":null,"compoundname":"InitShutAdmin","title":"Initialization and Shutdown","briefdescription":"","detaileddescription":"These functions are used for initialization of ROCm SMI and clean up when done.","includes":[],"memberdefs":[{"kind":"function","id":"group__InitShutAdmin_1ga2f427b6a84e2406daeb322cf77a7b0ca","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint64_t","declname":"init_flags","direction":"in","parameterdescription":"Bit flags that tell SMI how to initialze. Values of rsmi_init_flags_t may be OR'd together and passed through init_flags to modify how RSMI initializes."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_init","argsstring":"(uint64_t init_flags)","name":"rsmi_init","briefdescription":"Initialize ROCm SMI.","detaileddescription":"When called, this initializes internal data structures, including those corresponding to sources of information that SMI provides.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__InitShutAdmin_1ga354d175a5678aec1f3b2aa363f560940","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"void","declname":""}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_shut_down","argsstring":"(void)","name":"rsmi_shut_down","briefdescription":"Shutdown ROCm SMI.","detaileddescription":"Do any necessary clean up.","inbodydescription":null,"initializer":null,"returns":null}]}
{"id":"group__IDQuer","kind":"group","language":null,"prot":null,"compoundname":"IDQuer","title":"Identifier Queries","briefdescription":"","detaileddescription":"These functions provide identification information.","includes":[],"memberdefs":[{"kind":"function","id":"group__IDQuer_1ga320c921a8906c7c23b593f2e01afde7c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t *","declname":"num_devices","direction":"inout","parameterdescription":"Caller provided pointer to uint32_t. Upon successful call, the value num_devices will contain the number of monitor devices."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_num_monitor_devices","argsstring":"(uint32_t *num_devices)","name":"rsmi_num_monitor_devices","briefdescription":"Get the number of devices that have monitor information.","detaileddescription":"The number of devices which have monitors is returned. Monitors are referenced by the index which can be between 0 and - 1.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1gad9e05f1a9acc1a2095ac956d6704f412","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_id_get","briefdescription":"Get the device id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device id value to the uint64_t pointed to by . This ID is an identification of the type of device, so calling this function for different devices will give the same value if they are kind of device. Consequently, this function should not be used to distinguish one device from another. should be used to get a unique identifier.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gae0ce7ceb9dcb750814590eed083d3ca5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"revision","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device revision will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_revision_get","argsstring":"(uint32_t dv_ind, uint16_t *revision)","name":"rsmi_dev_revision_get","briefdescription":"Get the device revision associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t to which the revision will be written","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1ga71758627d0bf7a32b1396e8858005309","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"sku","direction":"inout","parameterdescription":"a pointer to char to which the sku will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_sku_get","argsstring":"(uint32_t dv_ind, char *sku)","name":"rsmi_dev_sku_get","briefdescription":"Get the SKU for a desired device associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a char , this function will attempt to obtain the SKU from the Product Information FRU chip, present on server ASICs. It will write the sku value to the char array pointed to by .If this parameter is nullptr, this function will return if the function is supported with the provided, arguments and if it is not supported with the provided arguments.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gaff4fc1b02761f4dd991a6326e35b7123","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device vendor id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vendor_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_vendor_id_get","briefdescription":"Get the device vendor id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device vendor id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1ga15f681e22f87270434f753542c8c46b3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_name_get","briefdescription":"Get the name string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the device (up to characters) to the buffer .If the integer ID associated with the device is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex device ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1gac7be897fab33a50b65b483b5c4c7c828","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"brand","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the brand will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer brand."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_brand_get","argsstring":"(uint32_t dv_ind, char *brand, uint32_t len)","name":"rsmi_dev_brand_get","briefdescription":"Get the brand string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the brand of the device (up to characters) to the buffer .If the sku associated with the device is not found as one of the values contained within rsmi_dev_brand_get, then this function will return the device marketing name as a string instead of the brand name.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1gac6e9bc242fa4fa7c641ec91adc8bf8aa","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vendor_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_vendor_name_get","briefdescription":"Get the name string for a give vendor ID.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the vendor (up to characters) buffer . The may be a device vendor or subsystem vendor ID.If the integer ID associated with the vendor is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex vendor ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga5664a8d8dbc8f3bd1a1aa0f3565b3973","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"brand","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the vram vendor will be written"},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer brand."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vram_vendor_get","argsstring":"(uint32_t dv_ind, char *brand, uint32_t len)","name":"rsmi_dev_vram_vendor_get","briefdescription":"Get the vram vendor string of a gpu device.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the vram vendor of the device (up to characters) to the buffer .If the vram vendor for the device is not found as one of the values contained within rsmi_dev_vram_vendor_get, then this function will return the string 'unknown' instead of the vram vendor.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__IDQuer_1gabe9c502ea30fbe6d66372f67cff313b3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"serial_num","direction":"inout","parameterdescription":"a pointer to caller-provided memory to which the serial number will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer serial_num."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_serial_number_get","argsstring":"(uint32_t dv_ind, char *serial_num, uint32_t len)","name":"rsmi_dev_serial_number_get","briefdescription":"Get the serial number string for a device.","detaileddescription":"Given a device index , a pointer to a buffer of chars , and the length of the provided buffer , this function will write the serial number string (up to characters) to the buffer pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga9f28d6a147d605085a0ff832eb1ed7df","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the subsystem device id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_subsystem_id_get","briefdescription":"Get the subsystem device id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the subsystem device id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gadd58554a73a901f911ed705fac6d6dc1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"name","direction":"inout","parameterdescription":"a pointer to a caller provided char buffer to which the name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"size_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_name_get","argsstring":"(uint32_t dv_ind, char *name, size_t len)","name":"rsmi_dev_subsystem_name_get","briefdescription":"Get the name string for the device subsytem.","detaileddescription":"Given a device index , a pointer to a caller provided char buffer , and a length of this buffer , this function will write the name of the device subsystem (up to characters) to the buffer .If the integer ID associated with the sub-system is not found in one of the system files containing device name information (e.g. \/usr\/share\/misc\/pci.ids), then this function will return the hex sub-system ID as a string. Updating the system name files can be accompplished with \"sudo update-pciids\".","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__IDQuer_1ga7231546b6feea52f39aa08e847efdfe6","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"minor","direction":"inout","parameterdescription":"a pointer to a uint32_t into which minor number will be copied"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_drm_render_minor_get","argsstring":"(uint32_t dv_ind, uint32_t *minor)","name":"rsmi_dev_drm_render_minor_get","briefdescription":"Get the drm minor number associated with this device.","detaileddescription":"Given a device index , find its render device file \/dev\/dri\/renderDN where N corresponds to its minor number.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_INIT_ERRORif failed to get minor number during initialization. RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gae3ce7d0f046867c9a9e3710018601c2b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device subsystem vendor id will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_subsystem_vendor_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_subsystem_vendor_id_get","briefdescription":"Get the device subsystem vendor id associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the device subsystem vendor id value to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1ga1eb4b9e02bfa817a2848530f93e58f3b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"id","direction":"inout","parameterdescription":"a pointer to uint64_t to which the unique ID of the GPU is written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_unique_id_get","argsstring":"(uint32_t dv_ind, uint64_t *id)","name":"rsmi_dev_unique_id_get","briefdescription":"Get Unique ID.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the unique ID of the GPU pointed to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__IDQuer_1gaab5f890bafa0a0e7fb596ca8974e4179","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"id"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_physical_id_get","argsstring":"(uint32_t dv_ind, uint16_t *id)","name":"rsmi_dev_xgmi_physical_id_get","briefdescription":"Get the XGMI physical id associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t to which the XGMI physical id will be written","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."}]}
{"id":"group__PCIeQuer","kind":"group","language":null,"prot":null,"compoundname":"PCIeQuer","title":"PCIe Queries","briefdescription":"","detaileddescription":"These functions provide information about PCIe.","includes":[],"memberdefs":[{"kind":"function","id":"group__PCIeQuer_1ga4d8c9b4115cfb5451dff297e7afec2e7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_pcie_bandwidth_t *","declname":"bandwidth","direction":"inout","parameterdescription":"a pointer to a caller provided rsmi_pcie_bandwidth_t structure to which the frequency information will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_bandwidth_get","argsstring":"(uint32_t dv_ind, rsmi_pcie_bandwidth_t *bandwidth)","name":"rsmi_dev_pci_bandwidth_get","briefdescription":"Get the list of possible PCIe bandwidths that are available.","detaileddescription":"Given a device index and a pointer to a to an structure , this function will fill in with the possible T\/s values and associated number of lanes, and indication of the current selection.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_UNEXPECTED_DATAData read or provided was not as expected"},{"kind":"function","id":"group__PCIeQuer_1gadcb3ec02149215346224d57d0002f9e2","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"bdfid","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device bdfid value will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_id_get","argsstring":"(uint32_t dv_ind, uint64_t *bdfid)","name":"rsmi_dev_pci_id_get","briefdescription":"Get the unique PCI device identifier associated for a device.","detaileddescription":"Give a device index and a pointer to a uint64_t , this function will write the Bus\/Device\/Function PCI identifier (BDFID) associated with device to the value pointed to by .The format of will be as follows:","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PCIeQuer_1ga97aa4ef153b3a01be39fb15ad60e0dc6","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"int32_t *","declname":"numa_node","direction":"inout","parameterdescription":"pointer to location where NUMA node value will be written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_numa_affinity_get","argsstring":"(uint32_t dv_ind, int32_t *numa_node)","name":"rsmi_topo_numa_affinity_get","briefdescription":"Get the NUMA node associated with a device.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will retrieve the NUMA node value associated with device and store the value at location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PCIeQuer_1ga23eeb9ad20791beb29b07db00567a5ce","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"sent","direction":"inout","parameterdescription":"a pointer to uint64_t to which the number of bytes sent will be written in 1 second. If pointer is NULL, it will be ignored."},{"type":"uint64_t *","declname":"received","direction":"inout","parameterdescription":"a pointer to uint64_t to which the number of bytes received will be written. If pointer is NULL, it will be ignored."},{"type":"uint64_t *","declname":"max_pkt_sz","direction":"inout","parameterdescription":"a pointer to uint64_t to which the maximum packet size will be written. If pointer is NULL, it will be ignored."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_throughput_get","argsstring":"(uint32_t dv_ind, uint64_t *sent, uint64_t *received, uint64_t *max_pkt_sz)","name":"rsmi_dev_pci_throughput_get","briefdescription":"Get PCIe traffic information.","detaileddescription":"Give a device index and pointers to a uint64_t's, , and , this function will write the number of bytes sent and received in 1 second to and , respectively. The maximum possible packet size will be written to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments"},{"kind":"function","id":"group__PCIeQuer_1gaa55edbb5b39096184747ab61edf19739","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"counter","direction":"inout","parameterdescription":"a pointer to uint64_t to which the sum of the NAK's received and generated by the GPU is written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_replay_counter_get","argsstring":"(uint32_t dv_ind, uint64_t *counter)","name":"rsmi_dev_pci_replay_counter_get","briefdescription":"Get PCIe replay counter.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the sum of the number of NAK's received by the GPU and the NAK's generated by the GPU to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__PCIeCont","kind":"group","language":null,"prot":null,"compoundname":"PCIeCont","title":"PCIe Control","briefdescription":"","detaileddescription":"These functions provide some control over PCIe.","includes":[],"memberdefs":[{"kind":"function","id":"group__PCIeCont_1gae158255eeb6a73bb00b042dedb2e73d3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"bw_bitmask","direction":"in","parameterdescription":"A bitmask indicating the indices of the bandwidths that are to be enabled (1) and disabled (0). Only the lowest rsmi_frequencies_t::num_supported (of rsmi_pcie_bandwidth_t) bits of this mask are relevant."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_pci_bandwidth_set","argsstring":"(uint32_t dv_ind, uint64_t bw_bitmask)","name":"rsmi_dev_pci_bandwidth_set","briefdescription":"Control the set of allowed PCIe bandwidths that can be used.","detaileddescription":"Given a device index and a 64 bit bitmask , this function will limit the set of allowable bandwidths. If a bit in has a value of 1, then the frequency (as ordered in an returned by ) corresponding to that bit index will be allowed.This function will change the performance level to in order to modify the set of allowable band_widths. Caller will need to set to in order to get back to default state.All bits with indices greater than or equal to the value of the field of will be ignored.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access"}]}
{"id":"group__PowerQuer","kind":"group","language":null,"prot":null,"compoundname":"PowerQuer","title":"Power Queries","briefdescription":"","detaileddescription":"These functions provide information about power usage.","includes":[],"memberdefs":[{"kind":"function","id":"group__PowerQuer_1ga4c261885296806cb39fa7aa1aa68fef2","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the average power consumption will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_ave_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *power)","name":"rsmi_dev_power_ave_get","briefdescription":"Get the average power consumption of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the current average power consumption (in microwatts) to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gafb3d36d17698b411c320982cc8f8da82","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"socket_power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the current socket power will be written to. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_current_socket_power_get","argsstring":"(uint32_t dv_ind, uint64_t *socket_power)","name":"rsmi_dev_current_socket_power_get","briefdescription":"Get the current socket power (also known as instant power) of the device index provided.","detaileddescription":"Given a device index and a pointer to a uint64_t , this function will write the current socket power (in microwatts) to the uint64_t pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga5c6fcd74be46ae056526c96d1a3ac09b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the current or average power will be written to. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"RSMI_POWER_TYPE *","declname":"type","direction":"inout","parameterdescription":"a pointer to RSMI_POWER_TYPE object. Returns the type of power retrieved from the device. Current power is RSMI_CURRENT_POWER and average power is RSMI_AVERAGE_POWER. If an error occurs, returns an invalid power type RSMI_INVALID_POWER."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_get","argsstring":"(uint32_t dv_ind, uint64_t *power, RSMI_POWER_TYPE *type)","name":"rsmi_dev_power_get","briefdescription":"A generic get which attempts to retieve current socket power (also known as instant power) of the device index provided, if not supported tries to get average power consumed by device. Current socket power is typically supported by newer devices, whereas average power is generally reported on older devices. This function aims to provide backwards compatability depending on device support.","detaileddescription":"Given a device index , a pointer to a uint64_t , and this function will write the current socket or average power (in microwatts) to the uint64_t pointed to by and a pointer to its RSMI_POWER_TYPE read.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga1f61b24edaca83a0e395a34c466fcf86","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"power","direction":"inout","parameterdescription":"a pointer to uint64_t to which the energy counter will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"float *","declname":"counter_resolution","direction":"inout","parameterdescription":"resolution of the counter power in micro Joules"},{"type":"uint64_t *","declname":"timestamp","direction":"inout","parameterdescription":"a pointer to uint64_t to which the timestamp will be written. Resolution: 1 ns."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_energy_count_get","argsstring":"(uint32_t dv_ind, uint64_t *power, float *counter_resolution, uint64_t *timestamp)","name":"rsmi_dev_energy_count_get","briefdescription":"Get the energy accumulator counter of the device with provided device index.","detaileddescription":"Given a device index , a pointer to a uint64_t , and a pointer to a uint64_t , this function will write amount of energy consumed to the uint64_t pointed to by , and the timestamp to the uint64_t pointed to by . The is an average of a short time. This function accumulates all energy consumed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gac8719065fb26a70cd6a08d6a2f8f4459","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"cap","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *cap)","name":"rsmi_dev_power_cap_get","briefdescription":"Get the cap on power which, when reached, causes the system to take action to reduce power.","detaileddescription":"When power use rises above the value , the system will take action to reduce power use. The power level returned through will be in microWatts.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1ga2e7a92f537eb6feaa4e6609783f7b6b7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"default_cap","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the default power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_default_get","argsstring":"(uint32_t dv_ind, uint64_t *default_cap)","name":"rsmi_dev_power_cap_default_get","briefdescription":"Get the default power cap for the device specified by .","detaileddescription":"The maximum power cap be temporarily changed by the user. However, this function always returns the default reset power cap. The power level returned through will be in microWatts.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PowerQuer_1gad551b35466b9bfdbeedbd27b470d4cea","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"max","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the maximum possible power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint64_t *","declname":"min","direction":"inout","parameterdescription":"a pointer to a uint64_t that indicates the minimum possible power cap, in microwatts If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_range_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max, uint64_t *min)","name":"rsmi_dev_power_cap_range_get","briefdescription":"Get the range of valid values for the power cap.","detaileddescription":"This function will return the maximum possible valid power cap and the minimum possible valid power cap","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__PowerCont","kind":"group","language":null,"prot":null,"compoundname":"PowerCont","title":"Power Control","briefdescription":"","detaileddescription":"These functions provide ways to control power usage.","includes":[],"memberdefs":[{"kind":"function","id":"group__PowerCont_1ga5679a8d267341b2f279b750b34cb9cde","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t","declname":"cap","direction":"in","parameterdescription":"a uint64_t that indicates the desired power cap, in microwatts"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_cap_set","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t cap)","name":"rsmi_dev_power_cap_set","briefdescription":"Set the power cap value.","detaileddescription":"This function will set the power cap to the provided value . must be between the minimum and maximum power cap values set by the system, which can be obtained from .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PowerCont_1gaad21b4498141a28eb8bfb886d0fb49bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"reserved","direction":"in","parameterdescription":"Not currently used. Set to 0."},{"type":"rsmi_power_profile_preset_masks_t","declname":"profile","direction":"in","parameterdescription":"a rsmi_power_profile_preset_masks_t that hold the mask of the desired new power profile"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_profile_set","argsstring":"(uint32_t dv_ind, uint32_t reserved, rsmi_power_profile_preset_masks_t profile)","name":"rsmi_dev_power_profile_set","briefdescription":"Set the power profile.","detaileddescription":"Given a device index and a , this function will attempt to set the current profile to the provided profile. The provided profile must be one of the currently supported profiles, as indicated by a call to","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_PERMISSIONfunction requires root access"}]}
{"id":"group__MemQuer","kind":"group","language":null,"prot":null,"compoundname":"MemQuer","title":"Memory Queries","briefdescription":"","detaileddescription":"These functions provide information about memory systems.","includes":[],"memberdefs":[{"kind":"function","id":"group__MemQuer_1ga623b5f74bb97ba8aafa634ef6b53c085","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_type_t","declname":"mem_type","direction":"in","parameterdescription":"The type of memory for which the total amount will be found"},{"type":"uint64_t *","declname":"total","direction":"inout","parameterdescription":"a pointer to uint64_t to which the total amount of memory will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_total_get","argsstring":"(uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *total)","name":"rsmi_dev_memory_total_get","briefdescription":"Get the total amount of memory that exists.","detaileddescription":"Given a device index , a type of memory , and a pointer to a uint64_t , this function will write the total amount of memory that exists to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gac16d840cd53ade019cc81f366156f1df","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_type_t","declname":"mem_type","direction":"in","parameterdescription":"The type of memory for which the amount being used will be found"},{"type":"uint64_t *","declname":"used","direction":"inout","parameterdescription":"a pointer to uint64_t to which the amount of memory currently being used will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_usage_get","argsstring":"(uint32_t dv_ind, rsmi_memory_type_t mem_type, uint64_t *used)","name":"rsmi_dev_memory_usage_get","briefdescription":"Get the current memory usage.","detaileddescription":"Given a device index , a type of memory , and a pointer to a uint64_t , this function will write the amount of memory that that is currently being used to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gafdedfdf70e3691903af4f8d88f8c8eb5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"busy_percent","direction":"inout","parameterdescription":"a pointer to the uint32_t to which the busy percent will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_busy_percent_get","argsstring":"(uint32_t dv_ind, uint32_t *busy_percent)","name":"rsmi_dev_memory_busy_percent_get","briefdescription":"Get percentage of time any device memory is being used.","detaileddescription":"Given a device index , this function returns the percentage of time that any device memory is being used for the specified device.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__MemQuer_1gae87be22a7c39b4dfacff962ec2aa55b5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"num_pages","direction":"inout","parameterdescription":"a pointer to a uint32. As input, the value passed through this parameter is the number of rsmi_retired_page_record_t's that may be safely written to the memory pointed to by records. This is the limit on how many records will be written to records. On return, num_pages will contain the number of records written to records, or the number of records that could have been written if enough memory had been provided. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"rsmi_retired_page_record_t *","declname":"records","direction":"inout","parameterdescription":"A pointer to a block of memory to which the rsmi_retired_page_record_t values will be written. This value may be NULL. In this case, this function can be used to query how many records are available to read."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_reserved_pages_get","argsstring":"(uint32_t dv_ind, uint32_t *num_pages, rsmi_retired_page_record_t *records)","name":"rsmi_dev_memory_reserved_pages_get","briefdescription":"Get information about reserved (\"retired\") memory pages.","detaileddescription":"Given a device index , this function returns retired page information corresponding to the device with the provided device index . The number of retired page records is returned through . may be NULL on input. In this case, the number of records available for retrieval will be returned through .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if more records were available than allowed by the provided, allocated memory."}]}
{"id":"group__PhysQuer","kind":"group","language":null,"prot":null,"compoundname":"PhysQuer","title":"Physical State Queries","briefdescription":"","detaileddescription":"These functions provide information about the physical characteristics of the device.","includes":[],"memberdefs":[{"kind":"function","id":"group__PhysQuer_1gab5facb2d80e3ccc5e06da213e03e1fda","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"int64_t *","declname":"speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_rpms_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed)","name":"rsmi_dev_fan_rpms_get","briefdescription":"Get the fan speed in RPMs of the device with the specified device index and 0-based sensor index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the current fan speed in RPMs to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1gab6764103231f0d26df73ffcc1e24dc06","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"int64_t *","declname":"speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, int64_t *speed)","name":"rsmi_dev_fan_speed_get","briefdescription":"Get the fan speed for the specified device as a value relative to .","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the current fan speed (a value between 0 and the maximum fan speed, ) to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga850b216c23c6fbb99ea2ed951b93aff1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t *","declname":"max_speed","direction":"inout","parameterdescription":"a pointer to uint32_t to which the maximum speed will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_max_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t *max_speed)","name":"rsmi_dev_fan_speed_max_get","briefdescription":"Get the max. fan speed of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the maximum fan speed possible to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga40e9da04e4c0cfa17a4f38b97ebc9669","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_type","direction":"in","parameterdescription":"part of device from which temperature should be obtained. This should come from the enum rsmi_temperature_type_t"},{"type":"rsmi_temperature_metric_t","declname":"metric","direction":"in","parameterdescription":"enum indicated which temperature value should be retrieved"},{"type":"int64_t *","declname":"temperature","direction":"inout","parameterdescription":"a pointer to int64_t to which the temperature will be written, in millidegrees Celcius. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_temp_metric_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_type, rsmi_temperature_metric_t metric, int64_t *temperature)","name":"rsmi_dev_temp_metric_get","briefdescription":"Get the temperature metric value for the specified metric, from the specified temperature sensor on the specified device.","detaileddescription":"Given a device index , a sensor type , a and a pointer to an int64_t , this function will write the value of the metric indicated by and to the memory location .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PhysQuer_1ga2f04a6d66a11f13eb73adb403ff968a7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_voltage_type_t","declname":"sensor_type","direction":"in","parameterdescription":"part of device from which voltage should be obtained. This should come from the enum rsmi_voltage_type_t"},{"type":"rsmi_voltage_metric_t","declname":"metric","direction":"in","parameterdescription":"enum indicated which voltage value should be retrieved"},{"type":"int64_t *","declname":"voltage","direction":"inout","parameterdescription":"a pointer to int64_t to which the voltage will be written, in millivolts. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_volt_metric_get","argsstring":"(uint32_t dv_ind, rsmi_voltage_type_t sensor_type, rsmi_voltage_metric_t metric, int64_t *voltage)","name":"rsmi_dev_volt_metric_get","briefdescription":"Get the voltage metric value for the specified metric, from the specified voltage sensor on the specified device.","detaileddescription":"Given a device index , a sensor type , a and a pointer to an int64_t , this function will write the value of the metric indicated by and to the memory location .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__PhysCont","kind":"group","language":null,"prot":null,"compoundname":"PhysCont","title":"Physical State Control","briefdescription":"","detaileddescription":"These functions provide control over the physical state of a device.","includes":[],"memberdefs":[{"kind":"function","id":"group__PhysCont_1gacecde26a5c3bff544ff7f54686d32866","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_reset","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind)","name":"rsmi_dev_fan_reset","briefdescription":"Reset the fan to automatic driver control.","detaileddescription":"This function returns control of the fan to the system","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments"},{"kind":"function","id":"group__PhysCont_1ga70853eb646b5f73e9e0b1c4ddfa20a91","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"uint64_t","declname":"speed","direction":"in","parameterdescription":"the speed to which the function will attempt to set the fan"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_fan_speed_set","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, uint64_t speed)","name":"rsmi_dev_fan_speed_set","briefdescription":"Set the fan speed for the specified device with the provided speed, in RPMs.","detaileddescription":"Given a device index and a integer value indicating speed , this function will attempt to set the fan speed to . An error will be returned if the specified speed is outside the allowable range for the device. The maximum value is 255 and the minimum is 0.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"}]}
{"id":"group__PerfQuer","kind":"group","language":null,"prot":null,"compoundname":"PerfQuer","title":"Clock, Power and Performance Queries","briefdescription":"","detaileddescription":"These functions provide information about clock frequencies and performance.","includes":[],"memberdefs":[{"kind":"function","id":"group__PerfQuer_1gaeea1357c0e3b6b0a733e0cf8c7334931","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"busy_percent","direction":"inout","parameterdescription":"a pointer to the uint32_t to which the busy percent will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_busy_percent_get","argsstring":"(uint32_t dv_ind, uint32_t *busy_percent)","name":"rsmi_dev_busy_percent_get","briefdescription":"Get percentage of time device is busy doing any processing.","detaileddescription":"Given a device index , this function returns the percentage of time that the specified device is busy. The device is considered busy if any one or more of its sub-blocks are working, and idle if none of the sub-blocks are working.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaa068351a61e17e7f134e7231db697f67","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_utilization_counter_t","declname":"utilization_counters","direction":"inout","parameterdescription":"Multiple utilization counters can be retreived with a single call. The caller must allocate enough space to the utilization_counters array. The caller also needs to set valid RSMI_UTILIZATION_COUNTER_TYPE type for each element of the array. RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"count","direction":"in","parameterdescription":"The size of utilization_counters array."},{"type":"uint64_t *","declname":"timestamp","direction":"inout","parameterdescription":"The timestamp when the counter is retreived. Resolution: 1 ns."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_utilization_count_get","argsstring":"(uint32_t dv_ind, rsmi_utilization_counter_t utilization_counters[], uint32_t count, uint64_t *timestamp)","name":"rsmi_utilization_count_get","briefdescription":"Get coarse grain utilization counter of the specified device.","detaileddescription":"Given a device index , the array of the utilization counters, the size of the array, this function returns the coarse grain utilization counters and timestamp. The counter is the accumulated percentages. Every milliseconds the firmware calculates % busy count and then accumulates that value in the counter. This provides minimally invasive coarse grain GPU usage information.If the function reutrns RSMI_STATUS_SUCCESS, the counter will be set in the value field of the .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga6eb7b45aebcadec18bd2766c416a24bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_activity_metric_t","declname":"activity_metric_type","direction":"in","parameterdescription":"a metric type"},{"type":"rsmi_activity_metric_counter_t *","declname":"activity_metric_counter","direction":"inout","parameterdescription":"Multiple utilization counters can be retrieved with a single call. The caller must allocate enough space to the rsmi_activity_metric_counter_t structure."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_activity_metric_get","argsstring":"(uint32_t dv_ind, rsmi_activity_metric_t activity_metric_type, rsmi_activity_metric_counter_t *activity_metric_counter)","name":"rsmi_dev_activity_metric_get","briefdescription":"Get activity metric average utilization counter of the specified device.","detaileddescription":"Given a device index , the activity metric type, this function returns the requested utilization countersIf the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding field of the counter will be set in the value field of the activity_metric_counter_t.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaea652953f9cd509908637ddeb6357484","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"avg_activity","direction":"inout","parameterdescription":"average bandwidth utilization counters can be retrieved"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_activity_avg_mm_get","argsstring":"(uint32_t dv_ind, uint16_t *avg_activity)","name":"rsmi_dev_activity_avg_mm_get","briefdescription":"Get activity metric bandwidth average utilization counter of the specified device.","detaileddescription":"Given a device index , the activity metric type, this function returns the requested utilization countersIf the function returns RSMI_STATUS_SUCCESS, the requested type will be set in the corresponding field of the counter will be set in the value field of the activity_metric_counter_t.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga3d5b926b493219b5cd76fb140b5a06d0","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t *","declname":"perf","direction":"inout","parameterdescription":"a pointer to rsmi_dev_perf_level_t to which the performance level will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_get","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t *perf)","name":"rsmi_dev_perf_level_get","briefdescription":"Get the performance level of the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga8d56e514c463fe4d7cbe02b652397078","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"Softmax value for GFXCLK in MHz."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_perf_determinism_mode_set","argsstring":"(uint32_t dv_ind, uint64_t clkvalue)","name":"rsmi_perf_determinism_mode_set","briefdescription":"Enter performance determinism mode with provided device index.","detaileddescription":"Given a device index and this function will enable performance determinism mode, which enforces a GFXCLK frequency SoftMax limit per GPU set by the user. This prevents the GFXCLK PLL from stretching when running the same workload on different GPUS, making performance variation minimal. This call will result in the performance level of the device being .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gacaea57ee1822bee9f7d401a1fb3ebbbb","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"od","direction":"inout","parameterdescription":"a pointer to uint32_t to which the overdrive percentage will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_get","argsstring":"(uint32_t dv_ind, uint32_t *od)","name":"rsmi_dev_overdrive_level_get","briefdescription":"Get the overdrive percent associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the overdrive percentage to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaee91eae3084fdd915e364af40778dac9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"od","direction":"inout","parameterdescription":"a pointer to uint32_t to which the overdrive percentage will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_mem_overdrive_level_get","argsstring":"(uint32_t dv_ind, uint32_t *od)","name":"rsmi_dev_mem_overdrive_level_get","briefdescription":"Get the memory clock overdrive percent associated with the device with provided device index.","detaileddescription":"Given a device index and a pointer to a uint32_t , this function will write the memory overdrive percentage to the uint32_t pointed to by","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gad329e66e21b7cf8826e83177b441257a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_clk_type_t","declname":"clk_type","direction":"in","parameterdescription":"the type of clock for which the frequency is desired"},{"type":"rsmi_frequencies_t *","declname":"f","direction":"inout","parameterdescription":"a pointer to a caller provided rsmi_frequencies_t structure to which the frequency information will be written. Frequency values are in Hz. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments. If multiple current frequencies are found, a warning is shown. If no current frequency is found, it is reflected as -1. If frequencies are not read from low to high a warning is shown as well."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_clk_freq_get","argsstring":"(uint32_t dv_ind, rsmi_clk_type_t clk_type, rsmi_frequencies_t *f)","name":"rsmi_dev_gpu_clk_freq_get","briefdescription":"Get the list of possible system clock speeds of device for a specified clock type.","detaileddescription":"Given a device index , a clock type , and a pointer to a to an structure , this function will fill in with the possible clock speeds, and indication of the current clock speed selection.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATAData read or provided was not as expected"},{"kind":"function","id":"group__PerfQuer_1ga53de4eb35a0236e80157faf7678d7839","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_gpu_reset","briefdescription":"Reset the gpu associated with the device with provided device index.","detaileddescription":"Given a device index , this function will reset the GPU","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga710288709a46ab3f26202a4c634a8ae1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_od_volt_freq_data_t *","declname":"odv","direction":"inout","parameterdescription":"a pointer to an rsmi_od_volt_freq_data_t structure If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_info_get","argsstring":"(uint32_t dv_ind, rsmi_od_volt_freq_data_t *odv)","name":"rsmi_dev_od_volt_info_get","briefdescription":"This function retrieves the voltage\/frequency curve information.","detaileddescription":"Given a device index and a pointer to a structure , this function will populate . See for more details.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga7f38c8ac3868cd9cfd1ada802e891c5b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_metrics_t *","declname":"pgpu_metrics","direction":"inout","parameterdescription":"a pointer to an rsmi_gpu_metrics_t structure If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_metrics_info_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_metrics_t *pgpu_metrics)","name":"rsmi_dev_gpu_metrics_info_get","briefdescription":"This function retrieves the gpu metrics information.","detaileddescription":"Given a device index and a pointer to a structure , this function will populate . See for more details.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga0084cc9338133bcae308ef056a730ea5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t","declname":"minclkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"uint64_t","declname":"maxclkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"rsmi_clk_type_t","declname":"clkType","direction":"in","parameterdescription":"RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_clk_range_set","argsstring":"(uint32_t dv_ind, uint64_t minclkvalue, uint64_t maxclkvalue, rsmi_clk_type_t clkType)","name":"rsmi_dev_clk_range_set","briefdescription":"This function sets the clock range information.","detaileddescription":"Given a device index , a minimum clock value , a maximum clock value and a clock type this function will set the sclk|mclk range","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga3b3886d657f883c81eababc53784237b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_freq_ind_t","declname":"level","direction":"in","parameterdescription":"RSMI_FREQ_IND_MIN|RSMI_FREQ_IND_MAX to set the minimum (0) or maximum (1) speed."},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"value to apply to the clock range. Frequency values are in MHz."},{"type":"rsmi_clk_type_t","declname":"clkType","direction":"in","parameterdescription":"RSMI_CLK_TYPE_SYS | RSMI_CLK_TYPE_MEM range type"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_clk_info_set","argsstring":"(uint32_t dv_ind, rsmi_freq_ind_t level, uint64_t clkvalue, rsmi_clk_type_t clkType)","name":"rsmi_dev_od_clk_info_set","briefdescription":"This function sets the clock frequency information.","detaileddescription":"Given a device index , a frequency level , a clock value and a clock type this function will set the sclk|mclk range","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1gaab312392d55b980848538e9461584174","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"vpoint","direction":"in","parameterdescription":"voltage point [0|1|2] on the voltage curve"},{"type":"uint64_t","declname":"clkvalue","direction":"in","parameterdescription":"clock value component of voltage curve point. Frequency values are in MHz."},{"type":"uint64_t","declname":"voltvalue","direction":"in","parameterdescription":"voltage value component of voltage curve point. Voltage is in mV."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_info_set","argsstring":"(uint32_t dv_ind, uint32_t vpoint, uint64_t clkvalue, uint64_t voltvalue)","name":"rsmi_dev_od_volt_info_set","briefdescription":"This function sets 1 of the 3 voltage curve points.","detaileddescription":"Given a device index , a voltage point and a voltage value this function will set voltage curve point","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga10b82fe6694e893829b879779648ad17","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"num_regions","direction":"inout","parameterdescription":"As input, this is the number of rsmi_freq_volt_region_t structures that can be written to buffer. As output, this is the number of rsmi_freq_volt_region_t structures that were actually written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"rsmi_freq_volt_region_t *","declname":"buffer","direction":"inout","parameterdescription":"a caller provided buffer to which rsmi_freq_volt_region_t structures will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_od_volt_curve_regions_get","argsstring":"(uint32_t dv_ind, uint32_t *num_regions, rsmi_freq_volt_region_t *buffer)","name":"rsmi_dev_od_volt_curve_regions_get","briefdescription":"This function will retrieve the current valid regions in the frequency\/voltage space.","detaileddescription":"Given a device index , a pointer to an unsigned integer and a buffer of structures, , this function will populate with the current frequency-volt space regions. The caller should assign to memory that can be written to by this function. The caller should also indicate the number of structures that can safely be written to in .The number of regions to expect this function provide () can be obtained by calling .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__PerfQuer_1ga2ce7fc9c727c1a1072aab6fe91619e2e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"sensor_ind","direction":"in","parameterdescription":"a 0-based sensor index. Normally, this will be 0. If a device has more than one sensor, it could be greater than 0."},{"type":"rsmi_power_profile_status_t *","declname":"status","direction":"inout","parameterdescription":"a pointer to rsmi_power_profile_status_t that will be populated by a call to this function If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_power_profile_presets_get","argsstring":"(uint32_t dv_ind, uint32_t sensor_ind, rsmi_power_profile_status_t *status)","name":"rsmi_dev_power_profile_presets_get","briefdescription":"Get the list of available preset power profiles and an indication of which profile is currently active.","detaileddescription":"Given a device index and a pointer to a , this function will set the bits of the bit field of to 1 if the profile corresponding to the respective profiles are enabled. For example, if both the VIDEO and VR power profiles are available selections, then AND'ed with will be non-zero as will AND'ed with . Additionally, will be set to the of the profile that is currently active.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__PerfCont","kind":"group","language":null,"prot":null,"compoundname":"PerfCont","title":"Clock, Power and Performance Control","briefdescription":"","detaileddescription":"These functions provide control over clock frequencies, power and performance.","includes":[],"memberdefs":[{"kind":"function","id":"group__PerfCont_1ga863fc15427807c89b6500e4d90b74024","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t","declname":"perf_lvl","direction":"in","parameterdescription":"the value to which the performance level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_set","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t perf_lvl)","name":"rsmi_dev_perf_level_set","briefdescription":"Set the PowerPlay performance level associated with the device with provided device index with the provided value.","detaileddescription":"Given a device index and an , this function will set the PowerPlay performance level for the device to the value .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1gaf135f00132c8507edd436469af6f480d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_dev_perf_level_t","declname":"perf_lvl","direction":"in","parameterdescription":"the value to which the performance level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_perf_level_set_v1","argsstring":"(uint32_t dv_ind, rsmi_dev_perf_level_t perf_lvl)","name":"rsmi_dev_perf_level_set_v1","briefdescription":"Set the PowerPlay performance level associated with the device with provided device index with the provided value.","detaileddescription":"Given a device index and an , this function will set the PowerPlay performance level for the device to the value .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1ga8f2adeb0167b9703f9c48ca5f83096a3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"od","direction":"in","parameterdescription":"the value to which the overdrive level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_set","argsstring":"(uint32_t dv_ind, uint32_t od)","name":"rsmi_dev_overdrive_level_set","briefdescription":"Set the overdrive percent associated with the device with provided device index with the provided value. See details for WARNING.","detaileddescription":"Given a device index and an overdrive level , this function will set the overdrive level for the device to the value . The overdrive level is an integer value between 0 and 20, inclusive, which represents the overdrive percentage; e.g., a value of 5 specifies an overclocking of 5%.The overdrive level is specific to the gpu system clock.The overdrive level is the percentage above the maximum Performance Level to which overclocking will be limited. The overclocking percentage does not apply to clock speeds other than the maximum. This percentage is limited to 20%.******WARNING****** Operating your AMD GPU outside of official AMD specifications or outside of factory settings, including but not limited to the conducting of overclocking (including use of this overclocking software, even if such software has been directly or indirectly provided by AMD or otherwise affiliated in any way with AMD), may cause damage to your AMD GPU, system components and\/or result in system failure, as well as cause other problems. DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S WARRANTY. Please use this utility with caution.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1ga006cd2d878b0505b3a173a640d2b253e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t","declname":"od","direction":"in","parameterdescription":"the value to which the overdrive level should be set"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_overdrive_level_set_v1","argsstring":"(uint32_t dv_ind, uint32_t od)","name":"rsmi_dev_overdrive_level_set_v1","briefdescription":"Set the overdrive percent associated with the device with provided device index with the provided value. See details for WARNING.","detaileddescription":"Given a device index and an overdrive level , this function will set the overdrive level for the device to the value . The overdrive level is an integer value between 0 and 20, inclusive, which represents the overdrive percentage; e.g., a value of 5 specifies an overclocking of 5%.The overdrive level is specific to the gpu system clock.The overdrive level is the percentage above the maximum Performance Level to which overclocking will be limited. The overclocking percentage does not apply to clock speeds other than the maximum. This percentage is limited to 20%.******WARNING****** Operating your AMD GPU outside of official AMD specifications or outside of factory settings, including but not limited to the conducting of overclocking (including use of this overclocking software, even if such software has been directly or indirectly provided by AMD or otherwise affiliated in any way with AMD), may cause damage to your AMD GPU, system components and\/or result in system failure, as well as cause other problems. DAMAGES CAUSED BY USE OF YOUR AMD GPU OUTSIDE OF OFFICIAL AMD SPECIFICATIONS OR OUTSIDE OF FACTORY SETTINGS ARE NOT COVERED UNDER ANY AMD PRODUCT WARRANTY AND MAY NOT BE COVERED BY YOUR BOARD OR SYSTEM MANUFACTURER'S WARRANTY. Please use this utility with caution.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCont_1gaad921c61f3227eb2c1f8ef33e2a8870b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_clk_type_t","declname":"clk_type","direction":"in","parameterdescription":"the type of clock for which the set of frequencies will be modified"},{"type":"uint64_t","declname":"freq_bitmask","direction":"in","parameterdescription":"A bitmask indicating the indices of the frequencies that are to be enabled (1) and disabled (0). Only the lowest rsmi_frequencies_t.num_supported bits of this mask are relevant."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_gpu_clk_freq_set","argsstring":"(uint32_t dv_ind, rsmi_clk_type_t clk_type, uint64_t freq_bitmask)","name":"rsmi_dev_gpu_clk_freq_set","briefdescription":"Control the set of allowed frequencies that can be used for the specified clock.","detaileddescription":"Given a device index , a clock type , and a 64 bit bitmask , this function will limit the set of allowable frequencies. If a bit in has a value of 1, then the frequency (as ordered in an returned by ) corresponding to that bit index will be allowed.This function will change the performance level to in order to modify the set of allowable frequencies. Caller will need to set to in order to get back to default state.All bits with indices greater than or equal to will be ignored.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_PERMISSIONfunction requires root access"}]}
{"id":"group__VersQuer","kind":"group","language":null,"prot":null,"compoundname":"VersQuer","title":"Version Queries","briefdescription":"","detaileddescription":"These functions provide version information about various subsystems.","includes":[],"memberdefs":[{"kind":"function","id":"group__VersQuer_1ga00d80783476c747e29f90aa7477b0a53","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_version_t *","declname":"version","direction":"inout","parameterdescription":"A pointer to an rsmi_version_t structure that will be updated with the version information upon return."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_version_get","argsstring":"(rsmi_version_t *version)","name":"rsmi_version_get","briefdescription":"Get the build version information for the currently running build of RSMI.","detaileddescription":"Get the major, minor, patch and build string for RSMI build currently in use through","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__VersQuer_1ga6d4f034afcef2e50b4e8392c5dfd7a57","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_sw_component_t","declname":"component","direction":"in","parameterdescription":"The component for which the version string is being requested"},{"type":"char *","declname":"ver_str","direction":"inout","parameterdescription":"A pointer to a buffer of char's to which the version of component will be written"},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer name."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_version_str_get","argsstring":"(rsmi_sw_component_t component, char *ver_str, uint32_t len)","name":"rsmi_version_str_get","briefdescription":"Get the driver version string for the current system.","detaileddescription":"Given a software component , a pointer to a char buffer, , this function will write the driver version string (up to characters) for the current system to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire name. In this case, only len bytes will be written."},{"kind":"function","id":"group__VersQuer_1ga2cad3e5c759f7e1f19b157e9d099ed4a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"vbios","direction":"inout","parameterdescription":"A pointer to a buffer of char's to which the VBIOS name will be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"The number of char's pointed to by vbios which can safely be written to by this function."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_vbios_version_get","argsstring":"(uint32_t dv_ind, char *vbios, uint32_t len)","name":"rsmi_dev_vbios_version_get","briefdescription":"Get the VBIOS identifer string.","detaileddescription":"Given a device ID , and a pointer to a char buffer, , this function will write the VBIOS string (up to characters) for device to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__VersQuer_1ga4a855a5c28e632b4e7c13a5640095620","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_fw_block_t","declname":"block","direction":"in","parameterdescription":"The firmware block for which the version is being requested"},{"type":"uint64_t *","declname":"fw_version","direction":"inout","parameterdescription":"The version for the firmware block If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_firmware_version_get","argsstring":"(uint32_t dv_ind, rsmi_fw_block_t block, uint64_t *fw_version)","name":"rsmi_dev_firmware_version_get","briefdescription":"Get the firmware versions for a device.","detaileddescription":"Given a device ID , and a pointer to a uint64_t, , this function will write the FW Versions as a string (up to characters) for device to . The caller must ensure that it is safe to write at least characters to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__ErrQuer","kind":"group","language":null,"prot":null,"compoundname":"ErrQuer","title":"Error Queries","briefdescription":"","detaileddescription":"These functions provide error information about RSMI calls as well as device errors.","includes":[],"memberdefs":[{"kind":"function","id":"group__ErrQuer_1ga91ec4eccaaeedf1b44e7d7fd8e4aa18e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_block_t","declname":"block","direction":"in","parameterdescription":"The block for which error counts should be retrieved"},{"type":"rsmi_error_count_t *","declname":"ec","direction":"inout","parameterdescription":"A pointer to an rsmi_error_count_t to which the error counts should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_count_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_error_count_t *ec)","name":"rsmi_dev_ecc_count_get","briefdescription":"Retrieve the error counts for a GPU block.","detaileddescription":"Given a device index , an and a pointer to an , this function will write the error count values for the GPU block indicated by to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1ga65da2dbb424d29175e9321846d6413bd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"enabled_blocks","direction":"inout","parameterdescription":"A pointer to a uint64_t to which the enabled blocks bits will be written. If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_enabled_get","argsstring":"(uint32_t dv_ind, uint64_t *enabled_blocks)","name":"rsmi_dev_ecc_enabled_get","briefdescription":"Retrieve the enabled ECC bit-mask.","detaileddescription":"Given a device index , and a pointer to a uint64_t , this function will write bits to memory pointed to by . Upon a successful call, can then be AND'd with elements of the ennumeration to determine if the corresponding block has ECC enabled. Note that whether a block has ECC enabled or not in the device is independent of whether there is kernel support for error counting for that block. Although a block may be enabled, but there may not be kernel support for reading error counters for that block.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1ga564d3ff08a256cbde3948809e38b8299","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_gpu_block_t","declname":"block","direction":"in","parameterdescription":"The block for which error counts should be retrieved"},{"type":"rsmi_ras_err_state_t *","declname":"state","direction":"inout","parameterdescription":"A pointer to an rsmi_ras_err_state_t to which the ECC state should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_ecc_status_get","argsstring":"(uint32_t dv_ind, rsmi_gpu_block_t block, rsmi_ras_err_state_t *state)","name":"rsmi_dev_ecc_status_get","briefdescription":"Retrieve the ECC status for a GPU block.","detaileddescription":"Given a device index , an and a pointer to an , this function will write the current state for the GPU block indicated by to memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__ErrQuer_1gaaf37a3e9252f0d37eac6d7b91a9c6ead","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_status_t","declname":"status","direction":"in","parameterdescription":"The error status for which a description is desired"},{"type":"const char **","declname":"status_string","direction":"inout","parameterdescription":"A pointer to a const char * which will be made to point to a description of the provided error code"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_status_string","argsstring":"(rsmi_status_t status, const char **status_string)","name":"rsmi_status_string","briefdescription":"Get a description of a provided RSMI error status.","detaileddescription":"Set the provided pointer to a const char *, , to a string containing a description of the provided error code .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call"}]}
{"id":"group__PerfCntr","kind":"group","language":null,"prot":null,"compoundname":"PerfCntr","title":"Performance Counter Functions","briefdescription":"","detaileddescription":"These functions are used to configure, query and control performance counting.These functions use the same mechanisms as the \"perf\" command line utility. They share the same underlying resources and have some similarities in how they are used. The events supported by this API should have corresponding perf events that can be seen with \"perf stat ...\". The events supported by perf can be seen with \"perf list\"The types of events available and the ability to count those events are dependent on which device is being targeted and if counters are still available for that device, respectively. can be used to see which event types () are supported for a given device. Assuming a device supports a given event type, we can then check to see if there are counters available to count a specific event with . Counters may be occupied by other perf based programs.Once it is determined that events are supported and counters are available, an event counter can be created\/destroyed and controlled. allocates internal data structures that will be used to used to control the event counter, and return a handle to this data structure.Once an event counter handle is obtained, the event counter can be controlled (i.e., started, stopped,...) with by passing commands. starts an event counter and stops a counter. reads an event counter.Once the counter is no longer needed, the resources it uses should be freed by calling .","includes":[],"memberdefs":[{"kind":"function","id":"group__PerfCntr_1gacc8df7e5918c52a5aa42379756b70d11","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"device index of device being queried"},{"type":"rsmi_event_group_t","declname":"group","direction":"in","parameterdescription":"rsmi_event_group_t identifier of group for which support is being queried"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_group_supported","argsstring":"(uint32_t dv_ind, rsmi_event_group_t group)","name":"rsmi_dev_counter_group_supported","briefdescription":"Tell if an event group is supported by a given device.","detaileddescription":"Given a device index and an event group specifier , tell if type events are supported by the device associated with","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSif the device associatee with dv_ind support counting events of the type indicated by group. RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments group"},{"kind":"function","id":"group__PerfCntr_1gaab82a28e74979ae7b0313096f47bec6e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_event_type_t","declname":"type","direction":"in","parameterdescription":"the rsmi_event_type_t of performance event to create"},{"type":"rsmi_event_handle_t *","declname":"evnt_handle","direction":"inout","parameterdescription":"A pointer to a rsmi_event_handle_t which will be associated with a newly allocated counter If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_create","argsstring":"(uint32_t dv_ind, rsmi_event_type_t type, rsmi_event_handle_t *evnt_handle)","name":"rsmi_dev_counter_create","briefdescription":"Create a performance counter object.","detaileddescription":"Create a performance counter object of type for the device with a device index of , and write a handle to the object to the memory location pointed to by . can be used with other performance event operations. The handle should be deallocated with when no longer needed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_OUT_OF_RESOURCESunable to allocate memory for counter RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga91e6477909591dc3558e3dcdb2e8d060","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evnt_handle","direction":"in","parameterdescription":"handle to event object to be deallocated"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_counter_destroy","argsstring":"(rsmi_event_handle_t evnt_handle)","name":"rsmi_dev_counter_destroy","briefdescription":"Deallocate a performance counter object.","detaileddescription":"Deallocate the performance counter object with the provided","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga662c37dfc32d75082834dc566fa72205","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evt_handle","direction":"in","parameterdescription":"an event handle"},{"type":"rsmi_counter_command_t","declname":"cmd","direction":"in","parameterdescription":"The event counter command to be issued"},{"type":"void *","declname":"cmd_args","direction":"inout","parameterdescription":"Currently not used. Should be set to NULL."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_control","argsstring":"(rsmi_event_handle_t evt_handle, rsmi_counter_command_t cmd, void *cmd_args)","name":"rsmi_counter_control","briefdescription":"Issue performance counter control commands.","detaileddescription":"Issue a command on the event counter associated with the provided handle .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga7299b0180746ddaa44b3653ad8cc2474","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_event_handle_t","declname":"evt_handle","direction":"in","parameterdescription":"an event handle"},{"type":"rsmi_counter_value_t *","declname":"value","direction":"inout","parameterdescription":"pointer to memory of size of rsmi_counter_value_t to which the counter value will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_read","argsstring":"(rsmi_event_handle_t evt_handle, rsmi_counter_value_t *value)","name":"rsmi_counter_read","briefdescription":"Read the current value of a performance counter.","detaileddescription":"Read the current counter value of the counter associated with the provided handle and write the value to the location pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_PERMISSIONfunction requires root access"},{"kind":"function","id":"group__PerfCntr_1ga8f410092c82feb4cf339d85adf717f01","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_event_group_t","declname":"grp","direction":"in","parameterdescription":"an event device group"},{"type":"uint32_t *","declname":"available","direction":"inout","parameterdescription":"A pointer to a uint32_t to which the number of available counters will be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_counter_available_counters_get","argsstring":"(uint32_t dv_ind, rsmi_event_group_t grp, uint32_t *available)","name":"rsmi_counter_available_counters_get","briefdescription":"Get the number of currently available counters.","detaileddescription":"Given a device index , a performance event group , and a pointer to a uint32_t , this function will write the number of type counters that are available on the device with index to the memory that points to.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__SysInfo","kind":"group","language":null,"prot":null,"compoundname":"SysInfo","title":"System Information Functions","briefdescription":"","detaileddescription":"These functions are used to configure, query and control performance counting.","includes":[],"memberdefs":[{"kind":"function","id":"group__SysInfo_1gafa7c4ee760160af2f13238a63f053a4c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_process_info_t *","declname":"procs","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which process information will be written. This may be NULL in which case only num_items will be updated with the number of processes found."},{"type":"uint32_t *","declname":"num_items","direction":"inout","parameterdescription":"A pointer to a uint32_t, which on input, should contain the amount of memory in rsmi_process_info_t's which have been provided by the procs argument. On output, if procs is non-NULL, this will be updated with the number rsmi_process_info_t structs actually written. If procs is NULL, this argument will be updated with the number processes for which there is information."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_get","argsstring":"(rsmi_process_info_t *procs, uint32_t *num_items)","name":"rsmi_compute_process_info_get","briefdescription":"Get process information about processes currently using GPU.","detaileddescription":"Given a non-NULL pointer to an array of 's, of length *, this function will write up to * instances of to the memory pointed to by . These instances contain information about each process utilizing a GPU. If is not NULL, will be updated with the number of processes actually written. If is NULL, will be updated with the number of processes for which there is current process information. Calling this function with being NULL is a way to determine how much memory should be allocated for when is not NULL.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if there were more processes for which information was available, but not enough space was provided as indicated by procs and num_items, on input."},{"kind":"function","id":"group__SysInfo_1gaf5c740b1fa460ddc8f2df6c18555120b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process ID for which process information is being requested"},{"type":"rsmi_process_info_t *","declname":"proc","direction":"inout","parameterdescription":"a pointer to a rsmi_process_info_t to which process information for pid will be written if it is found."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_by_pid_get","argsstring":"(uint32_t pid, rsmi_process_info_t *proc)","name":"rsmi_compute_process_info_by_pid_get","briefdescription":"Get process information about a specific process.","detaileddescription":"Given a pointer to an and a process id , this function will write the process information for , if available, to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_NOT_FOUNDis returned if there was no process information found for the provided pid"},{"kind":"function","id":"group__SysInfo_1ga819f64fd24a2c52202cac421c9156428","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process id of the process for which the number of gpus currently being used is requested"},{"type":"uint32_t *","declname":"dv_indices","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which indices of devices currently being used by the process will be written. This may be NULL in which case only num_devices will be updated with the number of devices being used."},{"type":"uint32_t *","declname":"num_devices","direction":"inout","parameterdescription":"A pointer to a uint32_t, which on input, should contain the amount of memory in uint32_t's which have been provided by the dv_indices argument. On output, if dv_indices is non-NULL, this will be updated with the number uint32_t's actually written. If dv_indices is NULL, this argument will be updated with the number devices being used."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_gpus_get","argsstring":"(uint32_t pid, uint32_t *dv_indices, uint32_t *num_devices)","name":"rsmi_compute_process_gpus_get","briefdescription":"Get the device indices currently being used by a process.","detaileddescription":"Given a process id , a non-NULL pointer to an array of uint32_t's of length *, this function will write up to device indices to the memory pointed to by . If is not NULL, will be updated with the number of gpu's currently being used by process . If is NULL, will be updated with the number of gpus currently being used by . Calling this function with being NULL is a way to determine how much memory is required for when is not NULL.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_INSUFFICIENT_SIZEis returned if there were more gpu indices that could have been written, but not enough space was provided as indicated by dv_indices and num_devices, on input."},{"kind":"function","id":"group__SysInfo_1ga380fba5bb8f7d8825981e7071670934f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"pid","direction":"in","parameterdescription":"The process id of the process for which the gpu currently being used is requested."},{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index where the process running on."},{"type":"rsmi_process_info_t *","declname":"proc","direction":"inout","parameterdescription":"a pointer to memory provided by the caller to which process information will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_compute_process_info_by_device_get","argsstring":"(uint32_t pid, uint32_t dv_ind, rsmi_process_info_t *proc)","name":"rsmi_compute_process_info_by_device_get","briefdescription":"Get the info of a process on a specific device.","detaileddescription":"Given a process id , a , this function will write the process information for pid on the device, if available, to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__XGMIInfo","kind":"group","language":null,"prot":null,"compoundname":"XGMIInfo","title":"XGMI Functions","briefdescription":"","detaileddescription":"These functions are used to configure, query and control XGMI.","includes":[],"memberdefs":[{"kind":"function","id":"group__XGMIInfo_1ga7d4c0f238ef2658db363b53967933abd","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_xgmi_status_t *","declname":"status","direction":"inout","parameterdescription":"A pointer to an rsmi_xgmi_status_t to which the XGMI error state should be written If this parameter is nullptr, this function will return RSMI_STATUS_INVALID_ARGS if the function is supported with the provided, arguments and RSMI_STATUS_NOT_SUPPORTED if it is not supported with the provided arguments."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_error_status","argsstring":"(uint32_t dv_ind, rsmi_xgmi_status_t *status)","name":"rsmi_dev_xgmi_error_status","briefdescription":"Retrieve the XGMI error status for a device.","detaileddescription":"Given a device index , and a pointer to an , this function will write the current XGMI error state for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__XGMIInfo_1gac3cf583cddbac54bed8f39b05539567b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_error_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_xgmi_error_reset","briefdescription":"Reset the XGMI error status for a device.","detaileddescription":"Given a device index , this function will reset the current XGMI error state for the device to rsmi_xgmi_status_t::RSMI_XGMI_STATUS_NO_ERRORS","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__XGMIInfo_1gaddca720006d546aaa3500aff76337770","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"hive_id","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the XGMI hive id should be written"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_xgmi_hive_id_get","argsstring":"(uint32_t dv_ind, uint64_t *hive_id)","name":"rsmi_dev_xgmi_hive_id_get","briefdescription":"Retrieve the XGMI hive id for a device.","detaileddescription":"Given a device index , and a pointer to an uint64_t , this function will write the current XGMI hive id for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function with the given arguments RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__HWTopo","kind":"group","language":null,"prot":null,"compoundname":"HWTopo","title":"Hardware Topology Functions","briefdescription":"","detaileddescription":"These functions are used to query Hardware topology.","includes":[],"memberdefs":[{"kind":"function","id":"group__HWTopo_1ga99bdcce451e3c64123b9cde07f56d23c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"numa_node","direction":"inout","parameterdescription":"A pointer to an uint32_t to which the numa node number should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_numa_node_number","argsstring":"(uint32_t dv_ind, uint32_t *numa_node)","name":"rsmi_topo_get_numa_node_number","briefdescription":"Retrieve the NUMA CPU node number for a device.","detaileddescription":"Given a device index , and a pointer to an uint32_t , this function will write the node number of NUMA CPU for the device to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga5bca00f4277b9236705180cc4f2a1374","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"weight","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the weight for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_link_weight","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *weight)","name":"rsmi_topo_get_link_weight","briefdescription":"Retrieve the weight for a connection between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , and a pointer to an uint64_t , this function will write the weight for the connection between the device and to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga7932d8de034046e2674849d85c09c899","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"min_bandwidth","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the minimal bandwidth for the connection should be written."},{"type":"uint64_t *","declname":"max_bandwidth","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the maximal bandwidth for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_minmax_bandwidth_get","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *min_bandwidth, uint64_t *max_bandwidth)","name":"rsmi_minmax_bandwidth_get","briefdescription":"Retreive minimal and maximal io link bandwidth between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , pointer to an uint64_t , and a pointer to uint64_t , this function will write theoretical minimal and maximal bandwidth limits. API works if src and dst are connected via xgmi and have 1 hop distance.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga27229edf8cd2a7cdcd2d2612152e8db1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"uint64_t *","declname":"hops","direction":"inout","parameterdescription":"A pointer to an uint64_t to which the hops for the connection should be written."},{"type":"RSMI_IO_LINK_TYPE *","declname":"type","direction":"inout","parameterdescription":"A pointer to an RSMI_IO_LINK_TYPE to which the type for the connection should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_topo_get_link_type","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, uint64_t *hops, RSMI_IO_LINK_TYPE *type)","name":"rsmi_topo_get_link_type","briefdescription":"Retrieve the hops and the connection type between GPU to GPU\/CPU.","detaileddescription":"Given a source device index and a destination device index , and a pointer to an uint64_t and a pointer to an RSMI_IO_LINK_TYPE , this function will write the number of hops and the connection type between the device and to the memory pointed to by and .To query the link type between GPU and CPU, given a source GPU index and a destination device index , a pointer to an uint64_t and a pointer to an RSMI_IO_LINK_TYPE , this function will write the number of hops and the connection type between the device and CPU to the memory pointed to by and .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"},{"kind":"function","id":"group__HWTopo_1ga91767a23b1025c571f44e53120857421","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind_src","direction":"in","parameterdescription":"the source device index"},{"type":"uint32_t","declname":"dv_ind_dst","direction":"in","parameterdescription":"the destination device index"},{"type":"bool *","declname":"accessible","direction":"inout","parameterdescription":"A pointer to a bool to which the status for the P2P connection availablity should be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_is_P2P_accessible","argsstring":"(uint32_t dv_ind_src, uint32_t dv_ind_dst, bool *accessible)","name":"rsmi_is_P2P_accessible","briefdescription":"Return P2P availability status between 2 GPUs.","detaileddescription":"Given a source device index and a destination device index , and a pointer to a bool , this function will write the P2P connection status between the device and to the memory pointed to by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid"}]}
{"id":"group__ComputePartition","kind":"group","language":null,"prot":null,"compoundname":"ComputePartition","title":"Compute Partition Functions","briefdescription":"","detaileddescription":"These functions are used to configure and query the device's compute parition setting.","includes":[],"memberdefs":[{"kind":"function","id":"group__ComputePartition_1gaf7bdbc0a7068bc74c32129a3baca2e8b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"compute_partition","direction":"inout","parameterdescription":"a pointer to a char string variable, which the device's current compute partition will be written to."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer compute_partition , suggested length is 4 or greater."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_get","argsstring":"(uint32_t dv_ind, char *compute_partition, uint32_t len)","name":"rsmi_dev_compute_partition_get","briefdescription":"Retrieves the current compute partitioning for a desired device.","detaileddescription":"Given a device index and a string , and uint32 , this function will attempt to obtain the device's current compute partition setting string. Upon successful retreival, the obtained device's compute partition settings string shall be stored in the passed char string variable.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESS call was successful RSMI_STATUS_INVALID_ARGS the provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATA data provided to function is not valid RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not support this function RSMI_STATUS_INSUFFICIENT_SIZE is returned if len bytes is not large enough to hold the entire compute partition value. In this case, only len bytes will be written."},{"kind":"function","id":"group__ComputePartition_1ga850de48a73477ccc471097dc172ff1e4","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_compute_partition_type_t","declname":"compute_partition","direction":"in","parameterdescription":"using enum rsmi_compute_partition_type_t, define what the selected device's compute partition setting should be updated to."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_set","argsstring":"(uint32_t dv_ind, rsmi_compute_partition_type_t compute_partition)","name":"rsmi_dev_compute_partition_set","briefdescription":"Modifies a selected device's compute partition setting.","detaileddescription":"Given a device index , a type of compute partition , this function will attempt to update the selected device's compute partition setting.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESS call was successful RSMI_STATUS_PERMISSION function requires root access RSMI_STATUS_INVALID_ARGS the provided arguments are not valid RSMI_STATUS_SETTING_UNAVAILABLE the provided setting is unavailable for current device RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not support this function RSMI_STATUS_BUSY A resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__ComputePartition_1ga05438b725fef9f413bb6f1ca084ffe6e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_compute_partition_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_compute_partition_reset","briefdescription":"Reverts a selected device's compute partition setting back to its boot state.","detaileddescription":"Given a device index , this function will attempt to revert its compute partition setting back to its boot state.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESS call was successful RSMI_STATUS_PERMISSION function requires root access RSMI_STATUS_NOT_SUPPORTED installed software or hardware does not support this function RSMI_STATUS_BUSY A resource or mutex could not be acquired because it is already being used - device is busy"}]}
{"id":"group__memory__partition","kind":"group","language":null,"prot":null,"compoundname":"memory_partition","title":"The Memory Partition Functions","briefdescription":"","detaileddescription":"These functions are used to query and set the device's current memory partition.","includes":[],"memberdefs":[{"kind":"function","id":"group__memory__partition_1ga2dc7c0a12b9fcb1c6fe9ded26524a6cc","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"char *","declname":"memory_partition","direction":"inout","parameterdescription":"a pointer to a char string variable, which the device's memory partition will be written to."},{"type":"uint32_t","declname":"len","direction":"in","parameterdescription":"the length of the caller provided buffer memory_partition , suggested length is 5 or greater."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_get","argsstring":"(uint32_t dv_ind, char *memory_partition, uint32_t len)","name":"rsmi_dev_memory_partition_get","briefdescription":"Retrieves the current memory partition for a desired device.","detaileddescription":"Given a device index and a string , and uint32 , this function will attempt to obtain the device's memory partition string. Upon successful retreival, the obtained device's memory partition string shall be stored in the passed char string variable.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_UNEXPECTED_DATAdata provided to function is not valid RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_INSUFFICIENT_SIZEis returned if len bytes is not large enough to hold the entire memory partition value. In this case, only len bytes will be written."},{"kind":"function","id":"group__memory__partition_1ga3e17898ccc0410df1646d35e5bf944b7","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"rsmi_memory_partition_type_t","declname":"memory_partition","direction":"in","parameterdescription":"using enum rsmi_memory_partition_type_t, define what the selected device's current mode setting should be updated to."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_set","argsstring":"(uint32_t dv_ind, rsmi_memory_partition_type_t memory_partition)","name":"rsmi_dev_memory_partition_set","briefdescription":"Modifies a selected device's current memory partition setting.","detaileddescription":"Given a device index and a type of memory partition , this function will attempt to update the selected device's memory partition setting.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_INVALID_ARGSthe provided arguments are not valid RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_AMDGPU_RESTART_ERRcould not successfully restart the amdgpu driver RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"},{"kind":"function","id":"group__memory__partition_1gad5712733c307d7297f8ab7dc01973563","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_memory_partition_reset","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_memory_partition_reset","briefdescription":"Reverts a selected device's memory partition setting back to its boot state.","detaileddescription":"Given a device index , this function will attempt to revert its current memory partition setting back to its boot state.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESScall was successful RSMI_STATUS_PERMISSIONfunction requires root access RSMI_STATUS_NOT_SUPPORTEDinstalled software or hardware does not support this function RSMI_STATUS_AMDGPU_RESTART_ERRcould not successfully restart the amdgpu driver RSMI_STATUS_BUSYA resource or mutex could not be acquired because it is already being used - device is busy"}]}
{"id":"group__APISupport","kind":"group","language":null,"prot":null,"compoundname":"APISupport","title":"Supported Functions","briefdescription":"","detaileddescription":"API function support varies by both GPU type and the version of the installed ROCm stack. The functions described in this section can be used to determine, up front, which functions are supported for a given device on a system. If such \"up front\" knowledge of support for a function is not needed, alternatively, one can call a device related function and check the return code.Some functions have several variations (\"variants\") where some variants are supported and others are not. For example, on a given device, may support some types of temperature metrics (e.g., ), but not others (e.g., ).In addition to a top level of variant support for a function, a function may have varying support for monitors\/sensors. These are considered \"sub-variants\" in functions described in this section. Continuing the example, if variant is supported, perhaps only the sub-variant sensors and are supported, but not .In cases where a function takes in a sensor id parameter but does not have any \"top level\" variants, the functions in this section will indicate a default \"variant\", , for the top level variant, and the various monitor support will be sub-variants of this.The functions in this section use the \"iterator\" concept to list which functions are supported; to list which variants of the supported functions are supported; and finally which monitors\/sensors are supported for a variant.Here is example code that prints out all supported functions, their supported variants and sub-variants. Please see the related descriptions functions and RSMI types.","includes":[],"memberdefs":[{"kind":"function","id":"group__APISupport_1ga8c14593e6886a1f63bc52d3a380fa50d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index of device for which support information is requested"},{"type":"rsmi_func_id_iter_handle_t *","declname":"handle","direction":"inout","parameterdescription":"A pointer to caller-provided memory to which the function iterator will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_func_iterator_open","argsstring":"(uint32_t dv_ind, rsmi_func_id_iter_handle_t *handle)","name":"rsmi_dev_supported_func_iterator_open","briefdescription":"Get a function name iterator of supported RSMI functions for a device.","detaileddescription":"Given a device index , this function will write a function iterator handle to the caller-provided memory pointed to by . This handle can be used to iterate through all the supported functions.Note that although this function takes in as an argument, itself will not be among the functions listed as supported. This is because does not depend on hardware or driver support and should always be supported.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga33c94fd59e341d5e879dcbe4efed9a2b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"obj_h","direction":"in","parameterdescription":"an iterator handle for which the variants are being requested"},{"type":"rsmi_func_id_iter_handle_t *","declname":"var_iter","direction":"inout","parameterdescription":"A pointer to caller-provided memory to which the sub-variant iterator will be written."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_variant_iterator_open","argsstring":"(rsmi_func_id_iter_handle_t obj_h, rsmi_func_id_iter_handle_t *var_iter)","name":"rsmi_dev_supported_variant_iterator_open","briefdescription":"Get a variant iterator for a given handle.","detaileddescription":"Given a , this function will write a function iterator handle to the caller-provided memory pointed to by . This handle can be used to iterate through all the supported variants of the provided handle. may be a handle to a function object, as provided by a call to , or it may be a variant itself (from a call to ), it which case will be an iterator of the sub-variants of (e.g., monitors).This call allocates a small amount of memory to . To free this memory should be called on the returned iterator handle when it is no longer needed.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga359b1a5ed84d1454a16541e77523dc9d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"handle","direction":"in","parameterdescription":"A pointer to an iterator handle to be incremented"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_func_iter_next","argsstring":"(rsmi_func_id_iter_handle_t handle)","name":"rsmi_func_iter_next","briefdescription":"Advance a function identifer iterator.","detaileddescription":"Given a function id iterator handle () , this function will increment the iterator to point to the next identifier. After a successful call to this function, obtaining the value of the iterator will provide the value of the next item in the list of functions\/variants.If there are no more items in the list, is returned.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NO_DATAis returned when list of identifiers has been exhausted"},{"kind":"function","id":"group__APISupport_1ga3e8d85fe092fc654014f1cc5e26e0268","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t *","declname":"handle","direction":"in","parameterdescription":"A pointer to an iterator handle to be closed"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_supported_func_iterator_close","argsstring":"(rsmi_func_id_iter_handle_t *handle)","name":"rsmi_dev_supported_func_iterator_close","briefdescription":"Close a variant iterator handle.","detaileddescription":"Given a pointer to an , this function will free the resources being used by the handle","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__APISupport_1ga0e70dbb9825f517e562bd6a782d05650","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"rsmi_func_id_iter_handle_t","declname":"handle","direction":"in","parameterdescription":"An iterator for which the value is being requested"},{"type":"rsmi_func_id_value_t *","declname":"value","direction":"inout","parameterdescription":"A pointer to an rsmi_func_id_value_t provided by the caller to which this function will write the value assocaited with handle"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_func_iter_value_get","argsstring":"(rsmi_func_id_iter_handle_t handle, rsmi_func_id_value_t *value)","name":"rsmi_func_iter_value_get","briefdescription":"Get the value associated with a function\/variant iterator.","detaileddescription":"Given an , this function will write the identifier of the function\/variant to the user provided memory pointed to by . may point to a function name, a variant id, or a monitor\/sensor index, depending on what kind of iterator is","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."}]}
{"id":"group__EvntNotif","kind":"group","language":null,"prot":null,"compoundname":"EvntNotif","title":"Event Notification Functions","briefdescription":"","detaileddescription":"These functions are used to configure for and get asynchronous event notifications.","includes":[],"memberdefs":[{"kind":"function","id":"group__EvntNotif_1gaba7582ffae49eaa4edebcb3a5b5c7d2a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":null,"parameterdescription":"a device index corresponding to the device on which to listen for events"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_init","argsstring":"(uint32_t dv_ind)","name":"rsmi_event_notification_init","briefdescription":"Prepare to collect event notifications for a GPU.","detaileddescription":"This function prepares to collect events for the GPU with device ID , by initializing any required system parameters. This call may open files which will remain open until is called.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."},{"kind":"function","id":"group__EvntNotif_1gae95cc3c3857bf4d3568789b894f1a494","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":null,"parameterdescription":"a device index corresponding to the device on which to listen for events"},{"type":"uint64_t","declname":"mask","direction":null,"parameterdescription":"Bitmask generated by OR'ing 1 or more elements of rsmi_evt_notification_type_t indicating which event types to listen for, where the rsmi_evt_notification_type_t value indicates the bit field, with bit position starting from 1. For example, if the mask field is 0x0000000000000003, which means first bit, bit 1 (bit position start from 1) and bit 2 are set, which indicate interest in receiving RSMI_EVT_NOTIF_VMFAULT (which has a value of 1) and RSMI_EVT_NOTIF_THERMAL_THROTTLE event (which has a value of 2)."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_mask_set","argsstring":"(uint32_t dv_ind, uint64_t mask)","name":"rsmi_event_notification_mask_set","briefdescription":"Specify which events to collect for a device.","detaileddescription":"Given a device index and a consisting of elements of OR'd together, this function will listen for the events specified in on the device corresponding to .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_INIT_ERRORis returned if rsmi_event_notification_init() has not been called before a call to this functionRSMI_STATUS_SUCCESSis returned upon successful call"},{"kind":"function","id":"group__EvntNotif_1ga79aa327ce4f2f09f150401123fcd8bd5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"int","declname":"timeout_ms","direction":"in","parameterdescription":"number of milliseconds to wait for an event to occur"},{"type":"uint32_t *","declname":"num_elem","direction":"inout","parameterdescription":"pointer to uint32_t, provided by the caller. On input, this value tells how many rsmi_evt_notification_data_t elements are being provided by the caller with data. On output, the location pointed to by num_elem will contain the number of items written to the provided buffer."},{"type":"rsmi_evt_notification_data_t *","declname":"data","direction":"out","parameterdescription":"pointer to a caller-provided memory buffer of size num_elem rsmi_evt_notification_data_t to which this function may safely write. If there are events found, up to num_elem event items will be written to data."}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_get","argsstring":"(int timeout_ms, uint32_t *num_elem, rsmi_evt_notification_data_t *data)","name":"rsmi_event_notification_get","briefdescription":"Collect event notifications, waiting a specified amount of time.","detaileddescription":"Given a time period in milliseconds and a caller- provided buffer of 's with a length (in 's, also specified by the caller) in the memory location pointed to by , this function will collect events for up to milliseconds, and write up to * event items to . Upon return is updated with the number of events that were actually written. If events are already present when this function is called, it will write the events to the buffer then poll for new events if there is still caller-provided buffer available to write any new events that would be found.This function requires prior calls to and . This function polls for the occurrance of the events on the respective devices that were previously specified by .","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSThe function ran successfully. The events that were found are written to data and num_elems is updated with the number of elements that were written.RSMI_STATUS_NO_DATANo events were found to collect."},{"kind":"function","id":"group__EvntNotif_1ga4077a7dd78683d0f867616f86a693275","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"The device index of the GPU for which event notification resources will be free"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_event_notification_stop","argsstring":"(uint32_t dv_ind)","name":"rsmi_event_notification_stop","briefdescription":"Close any file handles and free any resources used by event notification for a GPU.","detaileddescription":"Any resources used by event notification for the GPU with device index will be free with this function. This includes freeing any memory and closing file handles. This should be called for every call to","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_INVALID_ARGSresources for the given device have either already been freed, or were never allocated by rsmi_event_notification_init()RSMI_STATUS_SUCCESSis returned upon successful call"}]}
{"id":"group__GPU","kind":"group","language":null,"prot":null,"compoundname":"GPU","title":"Metric Functions","briefdescription":"","detaileddescription":"These functions are used to get granular information about all counters available in GPU Metrics.","includes":[],"memberdefs":[{"kind":"typedef","id":"group__GPU_1ga3eba939e0b9ebd015ad74c3df5467113","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricTempHbm_t[RSMI_NUM_HBM_INSTANCES]","argsstring":"[RSMI_NUM_HBM_INSTANCES]","name":"GPUMetricTempHbm_t","briefdescription":null,"detaileddescription":"Metric multi-valued counter types","inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gac477348c810cfce3cfa7c0d15ad8f907","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricVcnActivity_t[RSMI_MAX_NUM_VCNS]","argsstring":"[RSMI_MAX_NUM_VCNS]","name":"GPUMetricVcnActivity_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga7ae092a12d224f74635e4a0f26e2805c","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricJpegActivity_t[RSMI_MAX_NUM_JPEG_ENGS]","argsstring":"[RSMI_MAX_NUM_JPEG_ENGS]","name":"GPUMetricJpegActivity_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gae584e8a28cf43be0f6041f2802a8dd4c","prot":"public","static":"no","type":"uint64_t","definition":"typedef uint64_t GPUMetricXgmiReadDataAcc_t[RSMI_MAX_NUM_XGMI_LINKS]","argsstring":"[RSMI_MAX_NUM_XGMI_LINKS]","name":"GPUMetricXgmiReadDataAcc_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga810adbd48197678137b9a0279bcc66ff","prot":"public","static":"no","type":"uint64_t","definition":"typedef uint64_t GPUMetricXgmiWriteDataAcc_t[RSMI_MAX_NUM_XGMI_LINKS]","argsstring":"[RSMI_MAX_NUM_XGMI_LINKS]","name":"GPUMetricXgmiWriteDataAcc_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gab0a93bc0949ab898c379d9fa0988ada7","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrGfxClk_t[RSMI_MAX_NUM_GFX_CLKS]","argsstring":"[RSMI_MAX_NUM_GFX_CLKS]","name":"GPUMetricCurrGfxClk_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga716689f299e9b3fadc639445df2732ab","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrSocClk_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrSocClk_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1gafee46875174f8b107cf8ad4ded9907bd","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrVClk0_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrVClk0_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"typedef","id":"group__GPU_1ga5be7d659fa12d9524599e373b9185813","prot":"public","static":"no","type":"uint16_t","definition":"typedef uint16_t GPUMetricCurrDClk0_t[RSMI_MAX_NUM_CLKS]","argsstring":"[RSMI_MAX_NUM_CLKS]","name":"GPUMetricCurrDClk0_t","briefdescription":null,"detaileddescription":null,"inbodydescription":null,"initializer":null},{"kind":"function","id":"group__GPU_1ga235db82b8db19ab2b5819e09ebed5dad","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"hotspot_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_hotspot_get","argsstring":"(uint32_t dv_ind, uint16_t *hotspot_value)","name":"rsmi_dev_metrics_temp_hotspot_get","briefdescription":"Get the 'temp_hotspot' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_hotspot' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab6b6e0ab0348ae257575a09c8d020677","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"mem_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_mem_get","argsstring":"(uint32_t dv_ind, uint16_t *mem_value)","name":"rsmi_dev_metrics_temp_mem_get","briefdescription":"Get the 'temp_mem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_mem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab3f0b2e2bd7915b8aafd9a6fb2b0899c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrsoc_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrsoc_get","argsstring":"(uint32_t dv_ind, uint16_t *vrsoc_value)","name":"rsmi_dev_metrics_temp_vrsoc_get","briefdescription":"Get the 'temp_vrsoc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrsoc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga3b20cab9dde467f222bc91798e07fa9c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"socket_power_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_socket_power_get","argsstring":"(uint32_t dv_ind, uint16_t *socket_power_value)","name":"rsmi_dev_metrics_curr_socket_power_get","briefdescription":"Get the 'curr_socket_power' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'socket_power' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga33f1b3e5642d8a06a151363098ea2a45","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"gfx_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_gfx_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *gfx_activity_value)","name":"rsmi_dev_metrics_avg_gfx_activity_get","briefdescription":"Get the 'avg_gfx_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'gfx_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gadb3f5d55a0a2e2230e751f4bd6697f4b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"umc_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_umc_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *umc_activity_value)","name":"rsmi_dev_metrics_avg_umc_activity_get","briefdescription":"Get the 'avg_umc_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'umc_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaedc053805b82ee8971a23f6fa0630933","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"energy_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_energy_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *energy_acc_value)","name":"rsmi_dev_metrics_energy_acc_get","briefdescription":"Get the 'energy_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'energy_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga69fe25fc52880193ce3dc9bf56940160","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"system_clock_counter_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_system_clock_counter_get","argsstring":"(uint32_t dv_ind, uint64_t *system_clock_counter_value)","name":"rsmi_dev_metrics_system_clock_counter_get","briefdescription":"Get the 'system_clock_counter' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'system_clock_counter' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf6ca450a7a4bcbc243184e578c5e40f5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"firmware_timestamp_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_firmware_timestamp_get","argsstring":"(uint32_t dv_ind, uint64_t *firmware_timestamp_value)","name":"rsmi_dev_metrics_firmware_timestamp_get","briefdescription":"Get the 'firmware_timestamp' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'firmware_timestamp' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga61e5ce4e8fddc241658186f35360fd27","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"throttle_status_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_throttle_status_get","argsstring":"(uint32_t dv_ind, uint32_t *throttle_status_value)","name":"rsmi_dev_metrics_throttle_status_get","briefdescription":"Get the 'throttle_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'throttle_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga9d4a7a6f37ac79ca6afcaa380ad83504","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"pcie_link_width_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_link_width_get","argsstring":"(uint32_t dv_ind, uint16_t *pcie_link_width_value)","name":"rsmi_dev_metrics_pcie_link_width_get","briefdescription":"Get the 'pcie_link_width' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'pcie_link_width' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga71d48303828626ae12974659a8bda5ba","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"pcie_link_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_link_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *pcie_link_speed_value)","name":"rsmi_dev_metrics_pcie_link_speed_get","briefdescription":"Get the 'pcie_link_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'pcie_link_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga80fd8b72b3319bda4781f298b308d340","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xgmi_link_width_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_link_width_get","argsstring":"(uint32_t dv_ind, uint16_t *xgmi_link_width_value)","name":"rsmi_dev_metrics_xgmi_link_width_get","briefdescription":"Get the 'xgmi_link_width' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xgmi_link_width' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga5b0e21556be047e07e7f0d61f8210e72","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xgmi_link_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_link_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *xgmi_link_speed_value)","name":"rsmi_dev_metrics_xgmi_link_speed_get","briefdescription":"Get the 'xgmi_link_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xgmi_link_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7dafe8194d9134da38712ac42fc0bc52","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"gfxclk_lock_status_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_gfxclk_lock_status_get","argsstring":"(uint32_t dv_ind, uint32_t *gfxclk_lock_status_value)","name":"rsmi_dev_metrics_gfxclk_lock_status_get","briefdescription":"Get the 'gfxclk_lock_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'gfxclk_lock_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga2f61603bc7bc487d33fef8ba7a405b53","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"gfx_activity_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_gfx_activity_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *gfx_activity_acc_value)","name":"rsmi_dev_metrics_gfx_activity_acc_get","briefdescription":"Get the 'gfx_activity_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'gfx_activity_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga8d3f7a9d3f01fa2b08488c24aafedd98","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"mem_activity_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_mem_activity_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *mem_activity_acc_value)","name":"rsmi_dev_metrics_mem_activity_acc_get","briefdescription":"Get the 'mem_activity_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_activity_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga37263865409b458ca4187b792929e28e","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_bandwidth_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_bandwidth_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_bandwidth_acc_value)","name":"rsmi_dev_metrics_pcie_bandwidth_acc_get","briefdescription":"Get the 'pcie_bandwidth_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_bandwidth_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga40a167d188508c28da5508eb93d6cca5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_bandwidth_inst_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_bandwidth_inst_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_bandwidth_inst_value)","name":"rsmi_dev_metrics_pcie_bandwidth_inst_get","briefdescription":"Get the 'pcie_bandwidth_inst' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_bandwidth_inst' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga6cb8357b042d6142af29ef65d2927f19","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_l0_recov_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_l0_recov_count_acc_get","briefdescription":"Get the 'pcie_l0_recov_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_l0_recov_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga23a2ba7ce12d2c31a30f204b2b03e7ef","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_replay_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_replay_count_acc_get","briefdescription":"Get the 'pcie_replay_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_replay_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac79f7f0d22b4728d421f821aaf845fd5","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"pcie_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_replay_rover_count_acc_get","argsstring":"(uint32_t dv_ind, uint64_t *pcie_count_acc_value)","name":"rsmi_dev_metrics_pcie_replay_rover_count_acc_get","briefdescription":"Get the 'pcie_replay_rover_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'pcie_replay_rover_count_acc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac8ac6583d3b7912a82d6958c53402bad","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"pcie_nak_sent_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_nak_sent_count_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *pcie_nak_sent_count_acc_value)","name":"rsmi_dev_metrics_pcie_nak_sent_count_acc_get","briefdescription":"Get the 'pcie_nak_sent_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_max_bandwidth_usage' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gae9ebfed1f934aa10f189f7854d6b35bf","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint32_t *","declname":"pcie_nak_rcvd_count_acc_value","direction":"inout","parameterdescription":"a pointer to uint32_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_pcie_nak_rcvd_count_acc_get","argsstring":"(uint32_t dv_ind, uint32_t *pcie_nak_rcvd_count_acc_value)","name":"rsmi_dev_metrics_pcie_nak_rcvd_count_acc_get","briefdescription":"Get the 'pcie_nak_rcvd_count_acc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint32_t in which the 'mem_max_bandwidth_usage' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf06cf38ffc1b6d905bbe6a4a4a367056","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"uclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_uclk_get","argsstring":"(uint32_t dv_ind, uint16_t *uclk_value)","name":"rsmi_dev_metrics_curr_uclk_get","briefdescription":"Get the 'curr_uclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_uclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad2f37d6ee2707ffd51ec8126113cf041","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricTempHbm_t *","declname":"temp_hbm_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_NUM_HBM_INSTANCES) element array (GPUMetricTempHbm_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_hbm_get","argsstring":"(uint32_t dv_ind, GPUMetricTempHbm_t *temp_hbm_value)","name":"rsmi_dev_metrics_temp_hbm_get","briefdescription":"Get the 'temp_hbm' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_hbm' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga79b2808b7731f2428201a19066b44844","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricVcnActivity_t *","declname":"vcn_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_VCNS) element array (GPUMetricVcnActivity_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_vcn_activity_get","argsstring":"(uint32_t dv_ind, GPUMetricVcnActivity_t *vcn_activity_value)","name":"rsmi_dev_metrics_vcn_activity_get","briefdescription":"Get the 'vcn_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'vcn_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaff6aeb8024d61b53d2c863f0d43ca580","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricJpegActivity_t *","declname":"jpeg_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 32 (RSMI_MAX_NUM_JPEG_ENGS) element array (GPUMetricJpegActivity_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_jpeg_activity_get","argsstring":"(uint32_t dv_ind, GPUMetricJpegActivity_t *jpeg_activity_value)","name":"rsmi_dev_metrics_jpeg_activity_get","briefdescription":"Get the 'jpeg_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'vcn_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaac99d0b534ca00efbde025caa127d3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricXgmiReadDataAcc_t *","declname":"xgmi_read_data_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS) element array (GPUMetricXgmiReadDataAcc_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_read_data_get","argsstring":"(uint32_t dv_ind, GPUMetricXgmiReadDataAcc_t *xgmi_read_data_acc_value)","name":"rsmi_dev_metrics_xgmi_read_data_get","briefdescription":"Get the 'xgmi_read_data' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'xgmi_read_data' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafdeaca7b5d52cb3008f43c65b3244c1c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricXgmiWriteDataAcc_t *","declname":"xgmi_write_data_acc_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_XGMI_LINKS) element array (GPUMetricXgmiWriteDataAcc_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xgmi_write_data_get","argsstring":"(uint32_t dv_ind, GPUMetricXgmiWriteDataAcc_t *xgmi_write_data_acc_value)","name":"rsmi_dev_metrics_xgmi_write_data_get","briefdescription":"Get the 'xgmi_write_data' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'xgmi_write_data' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaedc8543c8dba375e457d05b3e4bc465","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrGfxClk_t *","declname":"current_gfxclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding an 8 (RSMI_MAX_NUM_GFX_CLKS) element array (GPUMetricCurrGfxClk_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_gfxclk_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrGfxClk_t *current_gfxclk_value)","name":"rsmi_dev_metrics_curr_gfxclk_get","briefdescription":"Get the 'curr_gfxclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'curr_gfxclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga4ace8508318e17343ee2c569e0dcb34a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrSocClk_t *","declname":"current_socclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrSocClk_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_socclk_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrSocClk_t *current_socclk_value)","name":"rsmi_dev_metrics_curr_socclk_get","briefdescription":"Get the 'curr_socclk' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_socclk' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafd61e106e116973d02701e822d3b7ab0","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrVClk0_t *","declname":"current_vclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrVClk0_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_vclk0_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrVClk0_t *current_vclk_value)","name":"rsmi_dev_metrics_curr_vclk0_get","briefdescription":"Get the 'curr_vclk0' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_vclk0' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad3cfab59d89131605ff519835fa4265b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"GPUMetricCurrDClk0_t *","declname":"current_dclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be storedThis is a multi-valued counter holding a 4 (RSMI_MAX_NUM_CLKS) element array (GPUMetricCurrDClk0_t)"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_dclk0_get","argsstring":"(uint32_t dv_ind, GPUMetricCurrDClk0_t *current_dclk_value)","name":"rsmi_dev_metrics_curr_dclk0_get","briefdescription":"Get the 'curr_dclk0' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_dclk0' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7df1376ff4805664035f32201280d3e1","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"edge_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_edge_get","argsstring":"(uint32_t dv_ind, uint16_t *edge_value)","name":"rsmi_dev_metrics_temp_edge_get","briefdescription":"Get the 'temp_edge' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_edge' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaed3ca62f4b7a42554d34ea3fb77dafd3","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrgfx_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrgfx_get","argsstring":"(uint32_t dv_ind, uint16_t *vrgfx_value)","name":"rsmi_dev_metrics_temp_vrgfx_get","briefdescription":"Get the 'temp_vrgfx' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrgfx' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga4536d67af9aad85e8583f010e73a91e9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"vrmem_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_temp_vrmem_get","argsstring":"(uint32_t dv_ind, uint16_t *vrmem_value)","name":"rsmi_dev_metrics_temp_vrmem_get","briefdescription":"Get the 'temp_vrmem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'temp_vrmem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga8e8196a531893531b093c5f80ecad50a","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"mm_activity_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_mm_activity_get","argsstring":"(uint32_t dv_ind, uint16_t *mm_activity_value)","name":"rsmi_dev_metrics_avg_mm_activity_get","briefdescription":"Get the 'avg_mm_activity' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_mm_activity' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga65a60575b31d68fca05f7ad300f7d412","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"current_vclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_vclk1_get","argsstring":"(uint32_t dv_ind, uint16_t *current_vclk_value)","name":"rsmi_dev_metrics_curr_vclk1_get","briefdescription":"Get the 'curr_vclk1' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_vclk1' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga71cbf01f5e18fb1342c8e087a807ab3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"current_dclk_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_dclk1_get","argsstring":"(uint32_t dv_ind, uint16_t *current_dclk_value)","name":"rsmi_dev_metrics_curr_dclk1_get","briefdescription":"Get the 'curr_dclk1' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_dclk1' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gac7f63ce12d98d75189ba86062eb9218c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint64_t *","declname":"throttle_status_value","direction":"inout","parameterdescription":"a pointer to uint64_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_indep_throttle_status_get","argsstring":"(uint32_t dv_ind, uint64_t *throttle_status_value)","name":"rsmi_dev_metrics_indep_throttle_status_get","briefdescription":"Get the 'indep_throttle_status' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint64_t in which the 'indep_throttle_status' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gad8dcf15777380183e3a812327dcfed95","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"socket_power_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_socket_power_get","argsstring":"(uint32_t dv_ind, uint16_t *socket_power_value)","name":"rsmi_dev_metrics_avg_socket_power_get","briefdescription":"Get the 'avg_socket_power' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_socket_power' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga02d935a7a7358c57ccfbb0a49f847689","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"fan_speed_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_curr_fan_speed_get","argsstring":"(uint32_t dv_ind, uint16_t *fan_speed_value)","name":"rsmi_dev_metrics_curr_fan_speed_get","briefdescription":"Get the 'curr_fan_speed' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'curr_fan_speed' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga862cc040b0b61cd3a0a71d9ba3dac30b","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_gfx_clock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_gfx_clock_frequency_get","briefdescription":"Get the 'avg_gfx_clock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_gfx_clock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga3ecc6556963b583beb18426839a5f582","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_soc_clock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_soc_clock_frequency_get","briefdescription":"Get the 'avg_soc_clock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_soc_clock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaeee03ae25ae1d82d24b4996d145be038","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_uclock_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_uclock_frequency_get","briefdescription":"Get the 'avg_uclock_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_uclock_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gae6384d1c91fea3c4a96f649d94292350","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_vclock0_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_vclock0_frequency_get","briefdescription":"Get the 'avg_vclock0_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_vclock0_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaacd2d36aae3a2260f0adcc34e9c85f3d","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_dclock0_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_dclock0_frequency_get","briefdescription":"Get the 'avg_dclock0_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_dclock0_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaf477b11657735e28369cb821938db651","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_vclock1_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_vclock1_frequency_get","briefdescription":"Get the 'avg_vclock1_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_vclock1_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga0a810f5446d35b0385f74b6cda422c3c","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"clock_frequency_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_avg_dclock1_frequency_get","argsstring":"(uint32_t dv_ind, uint16_t *clock_frequency_value)","name":"rsmi_dev_metrics_avg_dclock1_frequency_get","briefdescription":"Get the 'avg_dclock1_frequency' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'avg_dclock1_frequency' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga7d3439b56c71d14c3d1985e7389e47a9","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_soc_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_soc_get","briefdescription":"Get the 'volt_soc' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_soc' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga1c50b39c3ae7bd1020ba4bca53205a10","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_gfx_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_gfx_get","briefdescription":"Get the 'volt_gfx' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_gfx' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1ga1c1a5c21c3d861cc83f1fad10933de69","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"voltage_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_volt_mem_get","argsstring":"(uint32_t dv_ind, uint16_t *voltage_value)","name":"rsmi_dev_metrics_volt_mem_get","briefdescription":"Get the 'volt_mem' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'volt_mem' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gab730a6f75081e955266412c94051014f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"metrics_table_header_t *","declname":"header_value","direction":"inout","parameterdescription":"a pointer to metrics_table_header_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_header_info_get","argsstring":"(uint32_t dv_ind, metrics_table_header_t *header_value)","name":"rsmi_dev_metrics_header_info_get","briefdescription":"Get the 'metrics_header_info' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a in which the 'metrics_header_info' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gaaf2a1a098ed05868571387b73e24916f","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"},{"type":"uint16_t *","declname":"xcd_counter_value","direction":"inout","parameterdescription":"a pointer to uint16_t to which the device gpu metric unit will be stored"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_xcd_counter_get","argsstring":"(uint32_t dv_ind, uint16_t *xcd_counter_value)","name":"rsmi_dev_metrics_xcd_counter_get","briefdescription":"Get the 'xcd_counter' from the GPU metrics associated with the device.","detaileddescription":"Given a device index and a pointer to a uint16_t in which the 'xcd_counter' will stored","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call. RSMI_STATUS_NOT_SUPPORTED is returned in case the metric unit does not exist for the given device"},{"kind":"function","id":"group__GPU_1gafaf5ad7c0189346056ec8a5e5219d0cc","prot":"public","static":"no","const":"no","explicit":"no","inline":"no","virt":"non-virtual","param":[{"type":"uint32_t","declname":"dv_ind","direction":"in","parameterdescription":"a device index"}],"type":"rsmi_status_t","definition":"rsmi_status_t rsmi_dev_metrics_log_get","argsstring":"(uint32_t dv_ind)","name":"rsmi_dev_metrics_log_get","briefdescription":"Get the log from the GPU metrics associated with the device.","detaileddescription":"Given a device index it will log all the gpu metric info related to the device. The 'logging' feature must be on.","inbodydescription":null,"initializer":null,"returns":"RSMI_STATUS_SUCCESSis returned upon successful call."}]}
{"id":"deprecated","kind":"page","language":null,"prot":null,"compoundname":"deprecated","title":"Deprecated List","briefdescription":"","detaileddescription":"","includes":[],"memberdefs":[]}
{"id":"dir_d44c64559bbebec7f509842c48db8b23","kind":"dir","language":null,"prot":null,"compoundname":"include","title":"","briefdescription":"","detaileddescription":"","includes":[],"memberdefs":[]}
{"id":"dir_420a891a2250c54ae1f83615090de660","kind":"dir","language":null,"prot":null,"compoundname":"rocm_smi","title":"","briefdescription":"","detaileddescription":"","includes":[],"memberdefs":[]}
{"id":"indexpage","kind":"page","language":null,"prot":null,"compoundname":"index","title":"ROCm System Management Interface (ROCm SMI) Library","briefdescription":"","detaileddescription":"The ROCm System Management Interface Library, or ROCm SMI library, is part of the Radeon Open Compute software stack . It is a C library for Linux that provides a user space interface for applications to monitor and control GPU applications.For additional information refer to","includes":[],"memberdefs":[]}
