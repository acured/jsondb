{"command": "nvcc --output-file file", "description": "Specify name and location of the output file.", "other": "File and Path Specifications"}
{"command": "nvcc --objdir-as-tempdir", "description": "Create all intermediate files in the same directory as the object file. These intermediate files are deleted when the compilation is finished. This option will take effect only if -c, -dc or -dw is also used. Using this option will ensure that the intermediate file name that is embedded in the object file will not change in multiple compiles of the same file. However, this is not guaranteed if the input is stdin. If the same file is compiled with two different options, ex., \u2018nvcc -c t.cu\u2019 and \u2018nvcc -c -ptx t.cu\u2019, then the files should be compiled in different directories. Compiling them in the same directory can either cause the compilation to fail or produce incorrect results.", "other": "File and Path Specifications"}
{"command": "nvcc --pre-include file,...", "description": "Specify header files that must be pre-included during preprocessing.", "other": "File and Path Specifications"}
{"command": "nvcc --library library,...", "description": "Specify libraries to be used in the linking stage without the library file extension.\nThe libraries are searched for on the library search paths that have been specified using option --library-path (see Libraries).", "other": "File and Path Specifications"}
{"command": "nvcc --define-macro def,...", "description": "Define macros to be used during preprocessing.\ndef can be either name or name=definition.", "other": "File and Path Specifications"}
{"command": "nvcc --undefine-macro def,...", "description": "Undefine an existing macro during preprocessing or compilation.", "other": "File and Path Specifications"}
{"command": "nvcc --include-path path,...", "description": "Specify include search paths.", "other": "File and Path Specifications"}
{"command": "nvcc --system-include path,...", "description": "Specify system include search paths.", "other": "File and Path Specifications"}
{"command": "nvcc --library-path path,...", "description": "Specify library search paths (see Libraries).", "other": "File and Path Specifications"}
{"command": "nvcc --output-directory directory", "description": "Specify the directory of the output file.\nThis option is intended for letting the dependency generation step (see --generate-dependencies) generate a rule that defines the target object file in the proper directory.", "other": "File and Path Specifications"}
{"command": "nvcc --dependency-output file", "description": "Specify the dependency output file.\nThis option specifies the output file for the dependency generation step (see --generate-dependencies). The option --generate-dependencies or --generate-nonystem-dependencies must be specified if a dependency output file is set.", "other": "File and Path Specifications"}
{"command": "nvcc --generate-dependency-targets", "description": "Add an empty target for each dependency.\nThis option adds phony targets to the dependency generation step (see --generate-dependencies) intended to avoid makefile errors if old dependencies are deleted. The input files are not emitted as phony targets.", "other": "File and Path Specifications"}
{"command": "nvcc --compiler-bindir directory", "description": "Specify the directory in which the default host compiler executable resides.\nThe host compiler executable name can be also specified to ensure that the correct host compiler is selected. In addition, driver prefix options (--input-drive-prefix, --dependency-drive-prefix, or --drive-prefix) may need to be specified, if nvcc is executed in a Cygwin shell or a MinGW shell on Windows.", "other": "File and Path Specifications"}
{"command": "nvcc --allow-unsupported-compiler", "description": "Disable nvcc check for supported host compiler versions.\nUsing an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.", "other": "File and Path Specifications"}
{"command": "nvcc --archiver-binary executable", "description": "Specify the path of the archiver tool used create static library with --lib.", "other": "File and Path Specifications"}
{"command": "nvcc --cudart", "description": "Specify the type of CUDA runtime library to be used: no CUDA runtime library, shared/dynamic CUDA runtime library, or static CUDA runtime library.\nAllowed Values\nDefault\nThe static CUDA runtime library is used by default.", "other": "File and Path Specifications"}
{"command": "nvcc --cudadevrt", "description": "Specify the type of CUDA device runtime library to be used: no CUDA device runtime library, or static CUDA device runtime library.\nAllowed Values\nDefault\nThe static CUDA device runtime library is used by default.", "other": "File and Path Specifications"}
{"command": "nvcc --libdevice-directory directory", "description": "Specify the directory that contains the libdevice library files.\nLibdevice library files are located in the nvvm/libdevice directory in the CUDA Toolkit.", "other": "File and Path Specifications"}
{"command": "nvcc --target-directory string", "description": "Specify the subfolder name in the targets directory where the default include and library paths are located.", "other": "File and Path Specifications"}
{"command": "nvcc --link", "description": "Specify the default behavior: compile and link all input files.\nDefault Output File Name\na.exe on Windows or a.out on other platforms is used as the default output file name.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --lib", "description": "Compile all input files into object files, if necessary, and add the results to the specified library output file.\nDefault Output File Name\na.lib on Windows or a.a on other platforms is used as the default output file name.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --device-link", "description": "Link object files with relocatable device code and .ptx, .cubin, and .fatbin files into an object file with executable device code, which can be passed to the host linker.\nDefault Output File Name\na_dlink.obj on Windows or a_dlink.o on other platforms is used as the default output file name. When this option is used in conjunction with --fatbin, a_dlink.fatbin is used as the default output file name. When this option is used in conjunction with --cubin, a_dlink.cubin is used as the default output file name.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --device-c", "description": "Compile each .c, .cc, .cpp, .cxx, and .cu input file into an object file that contains relocatable device code.\nIt is equivalent to --relocatable-device-code=true --compile.\nDefault Output File Name\nThe source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --device-w", "description": "Compile each .c, .cc, .cpp, .cxx, and .cu input file into an object file that contains executable device code.\nIt is equivalent to --relocatable-device-code=false --compile.\nDefault Output File Name\nThe source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --cuda", "description": "Compile each .cu input file to a .cu.cpp.ii file.\nDefault Output File Name\n.cu.cpp.ii is appended to the basename of the source file name to create the default output file name. For example, the default output file name for x.cu is x.cu.cpp.ii.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --compile", "description": "Compile each .c, .cc, .cpp, .cxx, and .cu input file into an object file.\nDefault Output File Name\nThe source file name extension is replaced by .obj on Windows and .o on other platforms to create the default output file name. For example, the default output file name for x.cu is x.obj on Windows and x.o on other platforms.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --fatbin", "description": "Compile all .cu, .ptx, and .cubin input files to device-only .fatbin files.\nnvcc discards the host code for each .cu input file with this option.\nDefault Output File Name\nThe source file name extension is replaced by .fatbin to create the default output file name. For example, the default output file name for x.cu is x.fatbin.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --cubin", "description": "Compile all .cu and .ptx input files to device-only .cubin files.\nnvcc discards the host code for each .cu input file with this option.\nDefault Output File Name\nThe source file name extension is replaced by .cubin to create the default output file name. For example, the default output file name for x.cu is x.cubin.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --ptx", "description": "Compile all .cu input files to device-only .ptx files.\nnvcc discards the host code for each .cu input file with this option.\nDefault Output File Name\nThe source file name extension is replaced by .ptx to create the default output file name. For example, the default output file name for x.cu is x.ptx.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --preprocess", "description": "Preprocess all .c, .cc, .cpp, .cxx, and .cu input files.\nDefault Output File Name\nThe output is generated in stdout by default.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --generate-dependencies", "description": "Generate a dependency file that can be included in a Makefile for the .c, .cc, .cpp, .cxx, and .cu input file.\nnvcc uses a fixed prefix to identify dependencies in the preprocessed file ( \u2018#line 1\u2019 on Linux and \u2018# 1\u2019 on Windows). The files mentioned in source location directives starting with this prefix will be included in the dependency list.\nDefault Output File Name\nThe output is generated in stdout by default.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --generate-nonsystem-dependencies", "description": "Same as --generate-dependencies but skip header files found in system directories (Linux only).\nDefault Output File Name\nThe output is generated in stdout by default.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --generate-dependencies-with-compile", "description": "Generate a dependency file and compile the input file. The dependency file can be included in a Makefile for the .c, .cc, .cpp, .cxx, and .cu input file.\nThis option cannot be specified together with -E. The dependency file name is computed as follows:\nIf the dependency file name is computed based on either -MF or -o, then multiple input files are not supported.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --generate-nonsystem-dependencies-with-compile", "description": "Same as --generate-dependencies-with-compile but skip header files found in system directories (Linux only).", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --optix-ir", "description": "Compile CUDA source to OptiX IR (.optixir) output. The OptiX IR is only intended for consumption by OptiX through appropriate APIs. This feature is not supported with link-time-optimization (-dlto), the lto_NN -arch target, or with -gencode.\nDefault Output File Name\nThe source file name extension is replaced by .optixir to create the default output file name. For example, the default output file name for x.cu is x.optixir.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --run", "description": "Compile and link all input files into an executable, and executes it.\nWhen the input is a single executable, it is executed without any compilation or linking. This step is intended for developers who do not want to be bothered with setting the necessary environment variables; these are set temporarily by nvcc.", "other": "Options for Specifying the Compilation Phase"}
{"command": "nvcc --profile", "description": "Instrument generated code/executable for use by gprof.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --debug", "description": "Generate debug information for host code.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --device-debug", "description": "Generate debug information for device code.\nIf --dopt is not specified, then this option turns off all optimizations on device code. It is not intended for profiling; use --generate-line-info instead for profiling.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --extensible-whole-program", "description": "Generate extensible whole program device code, which allows some calls to not be resolved until linking with libcudadevrt.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --no-compress", "description": "Do not compress device code in fatbinary.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --generate-line-info", "description": "Generate line-number information for device code.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --optimization-info kind,...", "description": "Provide optimization reports for the specified kind of optimization.\nThe following tags are supported:\ninline", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --optimize level", "description": "Specify optimization level for host code.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --dopt kind", "description": "Enable device code optimization. When specified along with -G, enables limited debug information generation for optimized device code (currently, only line number information). When -G is not specified, -dopt=on is implicit.\nAllowed Values", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --dlink-time-opt", "description": "Perform link-time optimization of device code. The option \u2018-lto\u2019 is also an alias to \u2018-dlto\u2019. Link-time optimization must be specified at both compile and link time; at compile time it stores high-level intermediate code, then at link time it links together and optimizes the intermediate code. If that intermediate is not found at link time then nothing happens. Intermediate code is also stored at compile time with the --gpu-code='lto_NN' target. The options -dlto -arch=sm_NN will add a lto_NN target; if you want to only add a lto_NN target and not the compute_NN that -arch=sm_NN usually generates, use -arch=lto_NN.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --gen-opt-lto", "description": "Run the optimizer passes before generating the LTO IR.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --split-compile number", "description": "[Experimental] Perform compiler optimizations in parallel.\nSplit compilation attempts to reduce compile time by enabling the compiler to run certain optimization passes concurrently. It does this by splitting the device code into smaller translation units, each containing one or more device functions, and running optimization passes on each unit concurrently across multiple threads. It will then link back the split units prior to code generation.\nThe option accepts a numerical value that specifies the maximum number of threads the compiler can use. One can also allow the compiler to use the maximum threads available on the system by setting --split-compile=0. Setting --split-compile=1 will cause this option to be ignored.\nThis option can work in conjunction with device Link Time Optimization (-dlto) as well as --threads.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --ftemplate-backtrace-limit limit", "description": "Set the maximum number of template instantiation notes for a single warning or error to limit.\nA value of 0 is allowed, and indicates that no limit should be enforced. This value is also passed to the host compiler if it provides an equivalent flag.", "other": "Options for Specifying Behavior of Compiler/Linker"}
