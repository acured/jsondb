{"command": "nvcc --ftemplate-depth limit", "description": "Set the maximum instantiation depth for template classes to limit.\nThis value is also passed to the host compiler if it provides an equivalent flag.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --no-exceptions", "description": "Disable exception handling for host code.\nDisable exception handling for host code, by passing \u201c-EHs-c-\u201d (for cl.exe) and \u201c\u2013fno-exceptions\u201d (for other host compilers) during host compiler invocation. These flags are added to the host compiler invocation before any flags passed directly to the host compiler with \u201c-Xcompiler\u201d\nDefault (on Windows)\nExample (on Windows)", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --shared", "description": "Generate a shared library during linking.\nUse option --linker-options when other linker options are required for more control.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --x", "description": "Explicitly specify the language for the input files, rather than letting the compiler choose a default based on the file name suffix.\nAllowed Values\nDefault\nThe language of the source code is determined based on the file name suffix.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --std", "description": "Select a particular C++ dialect.\nAllowed Values\nDefault\nThe default C++ dialect depends on the host compiler. nvcc matches the default C++ dialect that the host compiler uses.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --no-host-device-initializer-list", "description": "Do not consider member functions of std::initializer_list as __host__ __device__ functions implicitly.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --expt-relaxed-constexpr", "description": "Experimental flag: Allow host code to invoke ``__device__ constexpr`` functions, and device code to invoke ``__host__ constexpr`` functions.\nNote that the behavior of this flag may change in future compiler releases.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --extended-lambda", "description": "Allow __host__, __device__ annotations in lambda declarations.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --expt-extended-lambda", "description": "Alias for --extended-lambda.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --machine", "description": "Specify 64-bit architecture.\nAllowed Values\nDefault\nThis option is set based on the host platform on which nvcc is executed.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --m64", "description": "Alias for --machine=64", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --host-linker-script", "description": "Use the host linker script (GNU/Linux only) to enable support for certain CUDA specific requirements, while building executable files or shared libraries.\nAllowed Values\nuse-lcs\ngen-lcs\nA linker script may already be in used and passed to the host linker using the host linker option --script (or -T), then the generated host linker script must augment the existing linker script. In such cases, the option -aug-hls must be used to generate linker script that contains only the augmentation parts. Otherwise, the host linker behaviour is undefined.\nA host linker option, such as -z with a non-default argument, that can modify the default linker script internally, is incompatible with this option and the behavior of any such usage is undefined.\nDefault Value\nuse-lcs is used as the default type.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --augment-host-linker-script", "description": "Enables generation of host linker script that augments an existing host linker script (GNU/Linux only). See option --host-linker-script for more details.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --host-relocatable-link", "description": "When used in combination with -hls=gen-lcs, controls the behaviour of -hls=gen-lcs and sets it to generate host linker script that can be used in host relocatable link (ld -r linkage). See option -hls=gen-lcs for more information.\nThis option currently is effective only when used with -hls=gen-lcs; in all other cases, this option is ignored currently.", "other": "Options for Specifying Behavior of Compiler/Linker"}
{"command": "nvcc --compiler-options options,...", "description": "Specify options directly to the compiler/preprocessor.", "other": "Options for Passing Specific Phase Options"}
{"command": "nvcc --linker-options options,...", "description": "Specify options directly to the host linker.", "other": "Options for Passing Specific Phase Options"}
{"command": "nvcc --archive-options options,...", "description": "Specify options directly to the library manager.", "other": "Options for Passing Specific Phase Options"}
{"command": "nvcc --ptxas-options options,...", "description": "Specify options directly to ptxas, the PTX optimizing assembler.", "other": "Options for Passing Specific Phase Options"}
{"command": "nvcc --nvlink-options options,...", "description": "Specify options directly to nvlink, the device linker.", "other": "Options for Passing Specific Phase Options"}
{"command": "nvcc --forward-unknown-to-host-compiler", "description": "Forward unknown options to the host compiler. An \u2018unknown option\u2019 is a command line argument that starts with - followed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag.\nIf the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the - character.\nFor example:", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --forward-unknown-to-host-linker", "description": "Forward unknown options to the host linker. An \u2018unknown option\u2019 is a command line argument that starts with - followed by another character, and is not a recognized nvcc flag or an argument for a recognized nvcc flag.\nIf the unknown option is followed by a separate command line argument, the argument will not be forwarded, unless it begins with the - character.\nFor example:", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --dont-use-profile", "description": "Do not use configurations from the nvcc.profile file for compilation.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --threads number", "description": "Specify the maximum number of threads to be used to execute the compilation steps in parallel.\nThis option can be used to improve the compilation speed when compiling for multiple architectures. The compiler creates number threads to execute the compilation steps in parallel. If number is 1, this option is ignored. If number is 0, the number of threads used is the number of CPUs on the machine.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --dryrun", "description": "List the compilation sub-commands without executing them.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --verbose", "description": "List the compilation sub-commands while executing them.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --keep", "description": "Keep all intermediate files that are generated during internal compilation steps.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --keep-dir directory", "description": "Keep all intermediate files that are generated during internal compilation steps in this directory.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --save-temps", "description": "This option is an alias of --keep.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --clean-targets", "description": "Delete all the non-temporary files that the same nvcc command would generate without this option.\nThis option reverses the behavior of nvcc. When specified, none of the compilation phases will be executed. Instead, all of the non-temporary files that nvcc would otherwise create will be deleted.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --run-args arguments,...", "description": "Specify command line arguments for the executable when used in conjunction with --run.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --use-local-env", "description": "Skip MSVC environment initialization.\nBy default nvcc assumes that the MSVC environment needs to be initialized. This is done by executing the appropriate command file available for the MSVC installation detected or specified. Initializing the environment for each nvcc invocation can add noticeable overheads. If the environment used to invoke nvcc has already been configured, this option can be used to skip this step.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --input-drive-prefix prefix", "description": "Specify the input drive prefix.\nOn Windows, all command line arguments that refer to file names must be converted to the Windows native format before they are passed to pure Windows executables. This option specifies how the current development environment represents absolute paths. Use /cygwin/ as prefix for Cygwin build environments and / as prefix for MinGW.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --dependency-drive-prefix prefix", "description": "Specify the dependency drive prefix.\nOn Windows, when generating dependency files (see --generate-dependencies), all file names must be converted appropriately for the instance of make that is used. Some instances of make have trouble with the colon in absolute paths in the native Windows format, which depends on the environment in which the make instance has been compiled. Use /cygwin/ as prefix for a Cygwin make, and / as prefix for MinGW. Or leave these file names in the native Windows format by specifying nothing.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --drive-prefix prefix", "description": "Specify the drive prefix.\nThis option specifies prefix as both --input-drive-prefix and --dependency-drive-prefix.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --dependency-target-name target", "description": "Specify the target name of the generated rule when generating a dependency file (see --generate-dependencies).", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --no-align-double", "description": "Specify that -malign-double should not be passed as a compiler argument on 32-bit platforms.\nWARNING: this makes the ABI incompatible with the CUDA\u2019s kernel ABI for certain 64-bit types.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --no-device-link", "description": "Skip the device link step when linking object files.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --allow-unsupported-compiler", "description": "Disable nvcc check for supported host compiler versions.\nUsing an unsupported host compiler may cause compilation failure or incorrect run time execution. Use at your own risk. This option has no effect on MacOS.", "other": "Options for Guiding the Compiler Driver"}
{"command": "nvcc --default-stream", "description": "Specify the stream that CUDA commands from the compiled program will be sent to by default.\nAllowed Values\nlegacy\nper-thread\nnull\nDefault\nlegacy is used as the default stream.", "other": "Options for Steering CUDA Compilation"}
{"command": "nvcc --gpu-architecture", "description": "Specify the name of the class of NVIDIA virtual GPU architecture for which the CUDA input files must be compiled.\nWith the exception as described for the shorthand below, the architecture specified with this option must be a virtual architecture (such as compute_50). Normally, this option alone does not trigger assembly of the generated PTX for a real architecture (that is the role of nvcc option --gpu-code, see below); rather, its purpose is to control preprocessing and compilation of the input to PTX.\nFor convenience, in case of simple nvcc compilations, the following shorthand is supported. If no value for option --gpu-code is specified, then the value of this option defaults to the value of --gpu-architecture. In this situation, as the only exception to the description above, the value specified for --gpu-architecture may be a real architecture (such as a sm_50), in which case nvcc uses the specified real architecture and its closest virtual architecture as the effective architecture values. For example, nvcc --gpu-architecture=sm_50 is equivalent to nvcc --gpu-architecture=compute_50\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 --gpu-code=sm_50,compute_50.\nWhen -arch=native is specified, nvcc detects the visible GPUs on the system and generates codes for them, no PTX program will be generated for this option. It is a warning if there are no visible supported GPU on the system, and the default architecture will be used.\nIf -arch=all is specified, nvcc embeds a compiled code image for all supported architectures (sm_*), and a PTX program for the highest major virtual architecture. For -arch=all-major, nvcc embeds a compiled code image for all supported major versions (sm_*0), plus the earliest supported, and adds a PTX program for the highest major virtual architecture.\nSee Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures.\nDefault\nsm_52 is used as the default value; PTX is generated for compute_52 then assembled and optimized for sm_52.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --gpu-code code,...", "description": "Specify the name of the NVIDIA GPU to assemble and optimize PTX for.\nnvcc embeds a compiled code image in the resulting executable for each specified code architecture, which is a true binary load image for each real architecture (such as sm_50), and PTX code for the virtual architecture (such as compute_50).\nDuring runtime, such embedded PTX code is dynamically compiled by the CUDA runtime system if no binary load image is found for the current GPU.\nArchitectures specified for options --gpu-architecture and --gpu-code may be virtual as well as real, but the code architectures must be compatible with the arch architecture. When the --gpu-code option is used, the value for the --gpu-architecture option must be a virtual PTX architecture.\nFor instance, --gpu-architecture=compute_60 is not compatible with --gpu-code=sm_52, because the earlier compilation stages will assume the availability of compute_60 features that are not present on sm_52.\nSee Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --generate-code specification", "description": "This option provides a generalization of the --gpu-architecture=arch --gpu-code=code,... option combination for specifying nvcc behavior with respect to code generation.\nWhere use of the previous options generates code for different real architectures with the PTX for the same virtual architecture, option --generate-code allows multiple PTX generations for different virtual architectures. In fact, --gpu-architecture=arch --gpu-code=code,... is equivalent to --generate-code=arch=arch,code=code,....\n--generate-code options may be repeated for different virtual architectures.\nSee Virtual Architecture Feature List for the list of supported virtual architectures and GPU Feature List for the list of supported real architectures.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --relocatable-device-code", "description": "Enable or disable the generation of relocatable device code.\nIf disabled, executable device code is generated. Relocatable device code must be linked before it can be executed.\nAllowed Values\nDefault\nThe generation of relocatable device code is disabled.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --entries entry,...", "description": "Specify the global entry functions for which code must be generated.\nPTX generated for all entry functions, but only the selected entry functions are assembled. Entry function names for this option must be specified in the mangled name.\nDefault\nnvcc generates code for all entry functions.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --maxrregcount amount", "description": "Specify the maximum amount of registers that GPU functions can use.\nUntil a function-specific limit, a higher value will generally increase the performance of individual GPU threads that execute this function. However, because thread registers are allocated from a global register pool on each GPU, a higher value of this option will also reduce the maximum thread block size, thereby reducing the amount of thread parallelism. Hence, a good maxrregcount value is the result of a trade-off.\nA value less than the minimum registers required by ABI will be bumped up by the compiler to ABI minimum limit.\nUser program may not be able to make use of all registers as some registers are reserved by compiler.\nDefault\nNo maximum is assumed.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --use_fast_math", "description": "Make use of fast math library.\n--use_fast_math implies --ftz=true --prec-div=false --prec-sqrt=false --fmad=true.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --ftz", "description": "Control single-precision denormals support.\n--ftz=true flushes denormal values to zero and --ftz=false preserves denormal values.\n--use_fast_math implies --ftz=true.\nAllowed Values\nDefault\nThis option is set to false and nvcc preserves denormal values.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --prec-div", "description": "This option controls single-precision floating-point division and reciprocals.\n--prec-div=true enables the IEEE round-to-nearest mode and --prec-div=false enables the fast approximation mode.\n--use_fast_math implies --prec-div=false.\nAllowed Values\nDefault\nThis option is set to true and nvcc enables the IEEE round-to-nearest mode.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --prec-sqrt", "description": "This option controls single-precision floating-point square root.\n--prec-sqrt=true enables the IEEE round-to-nearest mode and --prec-sqrt=false enables the fast approximation mode.\n--use_fast_math implies --prec-sqrt=false.\nAllowed Values\nDefault\nThis option is set to true and nvcc enables the IEEE round-to-nearest mode.", "other": "Options for Steering GPU Code Generation"}
{"command": "nvcc --fmad", "description": "This option enables (disables) the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).\n--use_fast_math implies --fmad=true.\nAllowed Values\nDefault\nThis option is set to true and nvcc enables the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add operations (FMAD, FFMA, or DFMA).", "other": "Options for Steering GPU Code Generation"}
